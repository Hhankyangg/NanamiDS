1
00:00:00,080 --> 00:00:02,280
大家好我是七海Nanami

2
00:00:02,280 --> 00:00:05,040
今天七海给大家带来数据结构的课程

3
00:00:05,040 --> 00:00:07,520
今天的内容是二叉搜索树

4
00:00:07,680 --> 00:00:08,360
前置知识

5
00:00:08,360 --> 00:00:11,680
是基础的复杂度分析和链表的知识

6
00:00:12,080 --> 00:00:14,120
脆鲨们知道这两个知识点

7
00:00:14,200 --> 00:00:16,800
就可以没有压力的看本视频了

8
00:00:17,200 --> 00:00:19,320
希望大家可以学有所获

9
00:00:20,280 --> 00:00:22,200
这是咱们第一节课程

10
00:00:22,200 --> 00:00:25,160
那就让咱们一起来看一下课程说明

11
00:00:25,440 --> 00:00:27,320
首先咱们的课程内容

12
00:00:27,320 --> 00:00:30,080
基于加州大学伯克利分校的数据结构

13
00:00:30,080 --> 00:00:31,800
课程的两个学期的内容

14
00:00:31,800 --> 00:00:34,720
2018年春和2023年秋

15
00:00:34,840 --> 00:00:36,360
所以大家可以理解为

16
00:00:36,360 --> 00:00:38,840
七海讲的就是课程的汉化内容

17
00:00:38,840 --> 00:00:39,400
只不过

18
00:00:39,400 --> 00:00:42,640
七海我稍微进行了一些提炼和总结

19
00:00:42,760 --> 00:00:45,960
其次课程使用的编程语言是Java

20
00:00:45,960 --> 00:00:49,080
不过课程不会过度注重于语言的实现

21
00:00:49,080 --> 00:00:51,480
所以脆鲨们只要会一门编程语言

22
00:00:51,480 --> 00:00:52,640
就可以听懂

23
00:00:52,880 --> 00:00:53,320
另外

24
00:00:53,320 --> 00:00:55,920
七海的语音模型是Bert-Vits2

25
00:00:55,920 --> 00:00:58,600
训练由Xz乔希完成

26
00:00:58,600 --> 00:01:00,240
感谢乔希同志

27
00:01:00,440 --> 00:01:01,920
最后七海想说

28
00:01:01,920 --> 00:01:03,520
七海现在也在学习中

29
00:01:03,520 --> 00:01:06,400
给大家讲的时候难免会出现错误

30
00:01:06,400 --> 00:01:07,720
请脆鲨包涵

31
00:01:07,720 --> 00:01:10,000
如果有错误请告诉我

32
00:01:10,280 --> 00:01:13,440
那就让我们开始这章内容的学习吧

33
00:01:13,560 --> 00:01:16,000
这一章我们学习搜索树

34
00:01:16,320 --> 00:01:17,880
至于为什么要是树

35
00:01:17,880 --> 00:01:18,800
它是怎么来的

36
00:01:18,800 --> 00:01:20,480
我们等会儿会讲到

37
00:01:20,680 --> 00:01:23,360
我们先整体的认识这个数据结构

38
00:01:23,360 --> 00:01:24,880
一个搜索树有三个

39
00:01:24,880 --> 00:01:28,120
最主要也是最基本的操作增，删，查

40
00:01:28,520 --> 00:01:30,480
增就是增加数据

41
00:01:30,480 --> 00:01:32,320
将数据加入到树中

42
00:01:32,720 --> 00:01:34,280
删就是删除数据

43
00:01:34,320 --> 00:01:35,880
查就是搜索数据

44
00:01:35,880 --> 00:01:36,760
可以返回布尔值是否找到

45
00:01:37,880 --> 00:01:40,800
也可以返回找到的那个对象的指针等

46
00:01:41,120 --> 00:01:44,880
搜索树中最基本的就是二叉搜索树

47
00:01:45,040 --> 00:01:48,200
在二叉搜索树的基础上做优化改进

48
00:01:48,200 --> 00:01:49,840
诞生了平衡树

49
00:01:49,840 --> 00:01:52,360
平衡树优化了操作的效率

50
00:01:52,560 --> 00:01:54,800
平衡树有很多的实现方法

51
00:01:54,800 --> 00:01:57,160
他们都可以让操作的时间复杂度

52
00:01:57,160 --> 00:01:58,600
缩短到对数

53
00:01:58,720 --> 00:02:00,440
其中我们要在这一章讲到

54
00:02:00,440 --> 00:02:04,520
不同的平衡树有 B树，AVL树和红黑树

55
00:02:04,640 --> 00:02:06,320
因为一节课要讲明白

56
00:02:06,320 --> 00:02:08,000
需要七海花很长时间

57
00:02:08,000 --> 00:02:10,880
所以这个视频我们只讲二叉搜索树

58
00:02:11,280 --> 00:02:12,720
二叉搜索树的产生

59
00:02:12,720 --> 00:02:15,480
可以从二分查找的角度直接出发

60
00:02:15,480 --> 00:02:15,960
这里

61
00:02:15,960 --> 00:02:18,920
七海假设大家没有学习过二分查找

62
00:02:18,920 --> 00:02:21,560
带大家理解二叉搜索树的产生

63
00:02:21,720 --> 00:02:24,400
我们已经具备了线性表的知识

64
00:02:24,760 --> 00:02:25,040
 

65
00:02:25,040 --> 00:02:27,040
在图中一个有序的链表中

66
00:02:27,040 --> 00:02:29,400
要从头开始搜索一个元素

67
00:02:29,400 --> 00:02:32,440
最差的情况下需要遍历所有元素

68
00:02:32,720 --> 00:02:34,080
我们也很容易知道

69
00:02:34,080 --> 00:02:35,440
在一个线性表中

70
00:02:35,440 --> 00:02:36,880
做遍历式的搜索

71
00:02:36,880 --> 00:02:40,200
需要的时间复杂都是线性的 O(N)

72
00:02:40,840 --> 00:02:42,440
现在的问题就是搜索实

73
00:02:42,440 --> 00:02:43,280
在是太慢了

74
00:02:43,280 --> 00:02:45,560
我们完全没有用到这个链表

75
00:02:45,560 --> 00:02:46,800
有序的特征

76
00:02:46,960 --> 00:02:48,680
我们应该怎么做呢

77
00:02:49,680 --> 00:02:51,240
我们可以任意的增加

78
00:02:51,240 --> 00:02:53,360
不同元素之间的连接线

79
00:02:53,360 --> 00:02:54,760
来缩短路程

80
00:02:55,000 --> 00:02:57,840
这种方法可以改进为一种数据结构

81
00:02:57,840 --> 00:02:59,600
也被叫做跳跃列表

82
00:02:59,600 --> 00:03:01,800
我们对它的讲解将止步于此

83
00:03:01,800 --> 00:03:04,440
感兴趣的脆鲨可以自行搜索

84
00:03:04,720 --> 00:03:06,520
我们也可以利用有序性

85
00:03:06,520 --> 00:03:09,480
将入口的指针移到中间的元素

86
00:03:09,920 --> 00:03:10,520
这还不够

87
00:03:10,520 --> 00:03:13,960
我们再将中间元素左边的指针反转

88
00:03:14,280 --> 00:03:16,400
这样在计算机搜索时

89
00:03:16,600 --> 00:03:19,040
若被搜索元素比中间的元素小

90
00:03:19,040 --> 00:03:20,240
就向左遍历

91
00:03:20,240 --> 00:03:22,680
若被搜索元素比中间的元素大

92
00:03:22,680 --> 00:03:23,880
就向右变例

93
00:03:24,120 --> 00:03:25,200
这就相当于

94
00:03:25,200 --> 00:03:27,640
我们缩短了列表一半的长度

95
00:03:27,640 --> 00:03:29,240
节省了一半的时间

96
00:03:29,240 --> 00:03:30,880
提升了一倍的效率

97
00:03:32,280 --> 00:03:33,360
这还不够好

98
00:03:33,360 --> 00:03:35,560
我们再把梦做大些

99
00:03:36,200 --> 00:03:38,240
我们在审视图一

100
00:03:38,720 --> 00:03:39,480
我们发现

101
00:03:39,480 --> 00:03:41,920
可以把左半边和右半边

102
00:03:42,000 --> 00:03:43,880
各自看作一个链表

103
00:03:43,880 --> 00:03:45,960
那为什么我们不像刚刚一样

104
00:03:45,960 --> 00:03:48,840
改变这两个子链表入口的位置

105
00:03:49,040 --> 00:03:51,760
我直接让中间元素的两边指针

106
00:03:51,760 --> 00:03:55,320
指向左半边的中间和右半边的中间

107
00:03:55,720 --> 00:03:57,720
就这样我们得到了图二

108
00:03:57,880 --> 00:04:00,440
有聪明的脆鲨可能要说了

109
00:04:00,600 --> 00:04:03,120
啊这不是一个二叉树吗

110
00:04:03,280 --> 00:04:04,720
恭喜你答对了

111
00:04:04,840 --> 00:04:06,760
这就是一棵二叉树

112
00:04:06,960 --> 00:04:09,280
这还是一棵二叉搜索树

113
00:04:09,640 --> 00:04:11,440
而且对于这个二叉树

114
00:04:11,440 --> 00:04:13,000
我们的搜索操作

115
00:04:13,000 --> 00:04:16,320
最多只用遍历三个元素就能给出答案

116
00:04:16,680 --> 00:04:17,920
比如我们要找A

117
00:04:17,920 --> 00:04:21,400
我们从入口开始先比A和D的大小

118
00:04:21,440 --> 00:04:23,080
A小那我们就沿左走

119
00:04:23,080 --> 00:04:26,000
走到B再比较A和B的大小

120
00:04:26,000 --> 00:04:27,920
A小那我们就再往左走

121
00:04:27,920 --> 00:04:29,240
然后我们就找到了

122
00:04:29,280 --> 00:04:32,040
那么就返回一个布尔值 true

123
00:04:32,160 --> 00:04:33,760
找B也是同理

124
00:04:34,080 --> 00:04:36,360
但是只需要看两个元素就够了

125
00:04:36,880 --> 00:04:39,720
如果要找一个不存在在树中的字母

126
00:04:39,720 --> 00:04:41,960
最后我们的指针会等于空指针

127
00:04:41,960 --> 00:04:43,920
然后我们返回错误就好了

128
00:04:44,040 --> 00:04:46,240
大致了解了二叉搜索树

129
00:04:46,240 --> 00:04:48,920
我们来看二叉搜索树的定义

130
00:04:49,160 --> 00:04:51,320
不知道各位脆鲨有没有了解过树

131
00:04:51,320 --> 00:04:54,280
七海先用两张幻灯片告诉大家

132
00:04:54,280 --> 00:04:55,160
什么是树

133
00:04:55,800 --> 00:04:58,360
树是一种有层次的数据结构

134
00:04:58,680 --> 00:04:59,720
具体来说

135
00:04:59,880 --> 00:05:01,280
树的定义有两点

136
00:05:01,280 --> 00:05:02,840
脆鲨们需要注意

137
00:05:04,040 --> 00:05:06,360
树是有限个结点的集合

138
00:05:06,360 --> 00:05:09,680
这个结点可以理解为链表的那个结点

139
00:05:10,120 --> 00:05:11,680
一个结点包含值

140
00:05:11,680 --> 00:05:14,040
包含指向其他结点的指针

141
00:05:15,400 --> 00:05:18,360
树有有限条边将结点连起来

142
00:05:18,360 --> 00:05:20,200
并且两个不同结点间

143
00:05:20,200 --> 00:05:22,240
有且只能有一条路径

144
00:05:22,400 --> 00:05:23,720
下面5个图中

145
00:05:23,720 --> 00:05:27,080
只有前三个图中图样表示一棵树

146
00:05:27,400 --> 00:05:29,880
比如图四为什么不是一棵树

147
00:05:30,320 --> 00:05:33,520
因为左右结点之间有两条不同的路径

148
00:05:34,080 --> 00:05:34,840
有问题的

149
00:05:34,840 --> 00:05:38,000
脆鲨这里可以暂停视频思考一下

150
00:05:38,360 --> 00:05:39,920
树还有三个概念

151
00:05:40,000 --> 00:05:41,400
脆鲨们需要注意

152
00:05:41,760 --> 00:05:44,040
一是父结点和子结点

153
00:05:44,040 --> 00:05:47,000
父结点就是一个结点被指向的结点

154
00:05:47,000 --> 00:05:49,840
子结点就是一个结点指向的结点

155
00:05:50,200 --> 00:05:52,160
二是根结点的定义

156
00:05:52,160 --> 00:05:54,640
根结点一般表示在树的顶层

157
00:05:54,640 --> 00:05:56,480
根结点没有父结点

158
00:05:56,760 --> 00:05:58,520
三是叶结点

159
00:05:58,520 --> 00:06:01,240
没有子结点的结点就是叶结点

160
00:06:01,680 --> 00:06:03,960
这几个概念其实非常形象

161
00:06:03,960 --> 00:06:05,120
还是不太理解的

162
00:06:05,120 --> 00:06:05,920
脆鲨可以

163
00:06:05,920 --> 00:06:07,480
看下面这个例子

164
00:06:07,760 --> 00:06:10,480
值为一的结点的父结点是零结点

165
00:06:10,480 --> 00:06:11,600
我们可以发现

166
00:06:11,600 --> 00:06:14,320
一个结点最多只有一个父结点

167
00:06:14,640 --> 00:06:17,680
一结点有三个子结点三，四，五

168
00:06:18,040 --> 00:06:21,000
我们发现一个结点可以有若干子结点

169
00:06:21,320 --> 00:06:25,800
而这棵树的叶子结点有四个，3 4 5 2 结点

170
00:06:26,800 --> 00:06:28,760
二叉树是一种特殊的树

171
00:06:28,760 --> 00:06:31,680
二叉树的每个结点的子结点数目

172
00:06:31,680 --> 00:06:33,640
只能是 0 1 2

173
00:06:33,960 --> 00:06:35,240
下面的两张图

174
00:06:35,240 --> 00:06:36,880
图一是二叉树

175
00:06:37,320 --> 00:06:40,800
图二因为第一个B结点有三个子结点

176
00:06:40,800 --> 00:06:42,400
所以不是二叉树

177
00:06:42,400 --> 00:06:45,400
下图还有一段简单的Java代码

178
00:06:48,200 --> 00:06:49,880
一个二叉树（结点）存储

179
00:06:49,880 --> 00:06:51,160
有一个整数值

180
00:06:51,160 --> 00:06:53,400
还有两个指向子树的指针

181
00:06:53,760 --> 00:06:56,680
指针可以指向其他的二叉树实例

182
00:06:56,680 --> 00:06:58,240
也可以是空指针

183
00:06:58,360 --> 00:07:01,440
所以这个类定义符合二叉树的标准

184
00:07:01,720 --> 00:07:03,280
二叉搜索树

185
00:07:03,400 --> 00:07:05,800
就是在二叉树的定义基础上

186
00:07:05,800 --> 00:07:07,960
再增加一些条件限制

187
00:07:08,280 --> 00:07:11,320
二叉搜索树的定义是这样说的

188
00:07:11,720 --> 00:07:14,560
一颗二叉搜索树的所有结点

189
00:07:14,560 --> 00:07:16,520
要满足以下两个要求

190
00:07:17,160 --> 00:07:20,800
一，一个结点左子树的所有结点的值

191
00:07:20,800 --> 00:07:22,440
小于这个结点的值

192
00:07:22,760 --> 00:07:25,600
二，一个结点右子树的

193
00:07:25,600 --> 00:07:28,920
所有结点的值大于这个结点的值

194
00:07:29,120 --> 00:07:31,320
那么对于下面的两张图

195
00:07:31,600 --> 00:07:33,680
左图是一颗二叉搜索树

196
00:07:33,680 --> 00:07:34,720
没有问题

197
00:07:35,040 --> 00:07:37,880
右图就不是一个二叉搜索树了

198
00:07:37,880 --> 00:07:40,120
虽然 7 大于 5，4 小于 7

199
00:07:40,560 --> 00:07:43,720
但是注意我们定义中的 所有 这两个字

200
00:07:43,720 --> 00:07:45,120
这里 4 小于 5

201
00:07:45,200 --> 00:07:47,920
所以这棵树不是二叉搜索树

202
00:07:48,320 --> 00:07:51,240
因为严格的大于和小于关系

203
00:07:51,240 --> 00:07:52,720
我们有以下推论

204
00:07:53,120 --> 00:07:55,600
二叉树不能有相同的值

205
00:07:55,760 --> 00:07:58,440
结点的值之间没有相等的情况

206
00:07:58,720 --> 00:08:00,160
在接下来的内容中

207
00:08:00,160 --> 00:08:03,640
我们的 二叉搜索树 类都是这样定义的

208
00:08:03,760 --> 00:08:06,880
一个二叉搜索树结点包含一个值

209
00:08:06,880 --> 00:08:09,360
值的类型是用户输入的 V 类型

210
00:08:09,360 --> 00:08:11,480
可以是整数字符串等

211
00:08:11,800 --> 00:08:12,840
除了包含值外

212
00:08:12,840 --> 00:08:16,000
一个结点还包含一个左子树指针

213
00:08:16,320 --> 00:08:17,840
一个右子树指针

214
00:08:18,160 --> 00:08:21,600
下面的两个函数就是两个二叉搜索树

215
00:08:21,600 --> 00:08:22,480
构造器

216
00:08:22,720 --> 00:08:26,400
不同的参数会匹配到不同的构造器

217
00:08:26,760 --> 00:08:29,680
了解了二叉搜索树的定义

218
00:08:30,120 --> 00:08:31,440
接下来我们就要看看

219
00:08:31,440 --> 00:08:34,960
二叉搜索树个 3 个操作是怎么完成的

220
00:08:35,240 --> 00:08:37,080
首先是搜索函数

221
00:08:37,520 --> 00:08:40,440
我们的搜索函数接收两个参数

222
00:08:40,440 --> 00:08:42,320
一个是要被搜索的树

223
00:08:42,320 --> 00:08:44,200
一个是要被搜索的值

224
00:08:44,440 --> 00:08:46,400
函数返回一个布尔值

225
00:08:46,400 --> 00:08:47,760
找到了就返回是

226
00:08:47,760 --> 00:08:49,360
没找到就返回否

227
00:08:49,680 --> 00:08:51,080
经过前面的学习

228
00:08:51,080 --> 00:08:53,840
我们的搜索策略已经显而易见

229
00:08:54,160 --> 00:08:57,320
如果要搜索值等于这个结点的值

230
00:08:57,320 --> 00:08:58,520
就返回是

231
00:08:58,760 --> 00:09:01,840
如果要搜索值小于这个结点的值

232
00:09:01,840 --> 00:09:03,600
就向左子树搜索

233
00:09:03,960 --> 00:09:07,120
如果要搜索值大于这个结点的值

234
00:09:07,160 --> 00:09:08,920
就向右子树搜索

235
00:09:09,480 --> 00:09:12,000
写成 Java 代码的样子如下

236
00:09:12,400 --> 00:09:13,560
我们很直觉地

237
00:09:13,560 --> 00:09:16,400
将这个函数写成递归函数

238
00:09:16,800 --> 00:09:18,640
注意没找到的情况就是

239
00:09:18,640 --> 00:09:21,480
当参数的树已经成了空值针时

240
00:09:21,720 --> 00:09:24,600
注意这里的代码实际上是不能编译的

241
00:09:24,600 --> 00:09:26,240
而且问题还不少

242
00:09:26,600 --> 00:09:27,560
不过问题不大

243
00:09:27,560 --> 00:09:29,280
我们只要理解了这用到

244
00:09:29,280 --> 00:09:32,040
的递归思想和搜索过程就好

245
00:09:32,320 --> 00:09:35,240
想要自己实现或者看严格实现步骤

246
00:09:35,240 --> 00:09:37,760
的脆鲨可以看简介的链接

247
00:09:38,000 --> 00:09:39,640
看完了操作的实现

248
00:09:39,640 --> 00:09:40,680
我们来分析一下

249
00:09:40,680 --> 00:09:43,640
二叉搜索树的搜索操作复杂度

250
00:09:44,000 --> 00:09:44,320
对于

251
00:09:44,320 --> 00:09:47,640
下面这棵长得十分“茂盛”的二叉搜索树

252
00:09:47,640 --> 00:09:50,800
最差情况的时间复杂度是多少呢

253
00:09:54,480 --> 00:09:56,080
答案是A

254
00:09:56,320 --> 00:09:57,400
脆鲨们做对了吗

255
00:09:57,400 --> 00:10:00,400
我们选取“比较元素的值”的操作次数 来看时间复杂度

256
00:10:02,680 --> 00:10:03,560
我们知道

257
00:10:03,560 --> 00:10:07,280
最差情况就是要搜索的值在叶子结点

258
00:10:07,680 --> 00:10:09,920
此时比较的次数最多

259
00:10:10,080 --> 00:10:12,160
那么次数又取决于什么呢

260
00:10:12,360 --> 00:10:14,360
聪明的脆鲨已经发现了

261
00:10:14,360 --> 00:10:16,320
次数就取决于层数

262
00:10:16,640 --> 00:10:19,840
对于这个二叉搜索树它有 3 层

263
00:10:19,840 --> 00:10:22,440
比较元素的值的最大次数是 4 次

264
00:10:22,440 --> 00:10:23,920
4 = 3 + 1

265
00:10:24,080 --> 00:10:26,440
而这样一棵茂盛的二叉树

266
00:10:26,440 --> 00:10:29,160
层数又和结点数有哪些关系呢

267
00:10:30,600 --> 00:10:32,400
其实就是对数的关系

268
00:10:32,400 --> 00:10:34,360
层数等于结点数加一

269
00:10:34,360 --> 00:10:36,360
对 2 的对数再减一

270
00:10:36,680 --> 00:10:39,000
实际上我们不用算得这么清楚

271
00:10:39,000 --> 00:10:42,360
只要能一眼看出是对数关系就足够了

272
00:10:42,600 --> 00:10:45,080
一棵茂盛的2叉搜索树

273
00:10:45,080 --> 00:10:46,600
实在是太快了

274
00:10:46,880 --> 00:10:49,720
假设我们每个操作需要一微秒

275
00:10:49,960 --> 00:10:51,720
那么当我们要查询一颗

276
00:10:51,720 --> 00:10:54,120
有十的三十万次方个结点的

277
00:10:54,120 --> 00:10:56,080
二叉搜索树的数据时

278
00:10:56,080 --> 00:10:58,040
最多只需要 1 秒钟

279
00:10:58,320 --> 00:11:00,560
那么这时有脆鲨可能要问了

280
00:11:00,560 --> 00:11:03,000
为什么七海一直在强调茂盛

281
00:11:03,080 --> 00:11:04,200
什么是茂盛

282
00:11:04,200 --> 00:11:05,920
不茂盛又会怎么样

283
00:11:06,240 --> 00:11:07,040
这个问题

284
00:11:07,040 --> 00:11:09,640
我们在下节课讲到平衡树的时候

285
00:11:09,640 --> 00:11:12,800
会讲到。脆鲨们也可以先积极思考

286
00:11:13,160 --> 00:11:14,920
看完了搜索操作

287
00:11:14,960 --> 00:11:17,160
接下来我们来看插入操作

288
00:11:17,600 --> 00:11:20,720
插入操作实际上是基于搜索操作的

289
00:11:20,720 --> 00:11:22,840
我们直接来看算法逻辑

290
00:11:23,400 --> 00:11:26,000
首先我们像此前的搜索算法一样

291
00:11:26,000 --> 00:11:27,680
查找要插入的值

292
00:11:28,280 --> 00:11:29,920
如果找到了这个值

293
00:11:29,920 --> 00:11:31,080
就什么都不做

294
00:11:31,520 --> 00:11:33,280
如果没有找到这个值

295
00:11:33,360 --> 00:11:36,280
那么我们此时一定在某个叶子结点

296
00:11:36,280 --> 00:11:37,080
的左指针

297
00:11:37,080 --> 00:11:38,240
或者右指针

298
00:11:41,120 --> 00:11:42,440
把值放进去

299
00:11:42,440 --> 00:11:43,760
再用指针连接

300
00:11:43,760 --> 00:11:44,440
就好

301
00:11:44,520 --> 00:11:47,320
比如我们要在右边这棵树中插入 7

302
00:11:47,320 --> 00:11:49,200
我们按照步骤来

303
00:11:49,440 --> 00:11:51,520
首先我们开始查找 7 

304
00:11:52,000 --> 00:11:53,840
一直找到 6 的右子树

305
00:11:53,840 --> 00:11:55,240
发现是空指针了

306
00:11:55,240 --> 00:11:57,240
也就是说这棵树没有 7

307
00:11:57,480 --> 00:11:59,880
那么我们就新建结点

308
00:11:59,880 --> 00:12:01,760
结点的值是 7

309
00:12:02,160 --> 00:12:04,760
最后再将指针调整就行了

310
00:12:05,280 --> 00:12:07,680
将以上操作写成代码

311
00:12:07,960 --> 00:12:11,120
注意这个代码仍然是非常非常简化版

312
00:12:11,120 --> 00:12:12,400
是不能编译的

313
00:12:12,480 --> 00:12:13,720
我们来仔细看看

314
00:12:13,720 --> 00:12:16,680
我们这个递归函数的实现方式

315
00:12:17,040 --> 00:12:20,400
首先这个函数的返回值类型是二叉搜索树

316
00:12:21,240 --> 00:12:24,560
而不是很多脆鲨直觉中的没有返回值

317
00:12:24,880 --> 00:12:27,440
这个函数对于一些初学脆鲨来说

318
00:12:27,440 --> 00:12:28,400
可能有点怪

319
00:12:28,400 --> 00:12:30,080
我们发现无论怎么插入

320
00:12:30,080 --> 00:12:31,280
最后的返回值

321
00:12:31,280 --> 00:12:31,920
都是一个

322
00:12:31,920 --> 00:12:34,960
已经插入了值的二叉树的根结点

323
00:12:35,160 --> 00:12:38,040
一些脆鲨可能会像右图这么想

324
00:12:38,160 --> 00:12:40,280
这似乎更加符合直觉

325
00:12:40,640 --> 00:12:42,520
但是如果你愿意去试一试

326
00:12:42,520 --> 00:12:43,400
你会发现

327
00:12:43,400 --> 00:12:46,280
右边的代码更加复杂与不优美

328
00:12:46,520 --> 00:12:47,720
一个好脆鲨

329
00:12:47,720 --> 00:12:50,760
应该学会像左边这样写递归代码

330
00:12:51,120 --> 00:12:54,280
接下来让我们来看最后一个操作删除

331
00:12:54,720 --> 00:12:55,880
二叉搜索树的

332
00:12:55,880 --> 00:12:57,600
删除操作比较的麻烦

333
00:12:57,600 --> 00:13:00,320
我们在这一部分不会讲到代码实现

334
00:13:00,320 --> 00:13:03,200
好奇的脆鲨请看简介中的资料

335
00:13:03,680 --> 00:13:05,280
首先我们很容易意识到

336
00:13:05,280 --> 00:13:07,400
删除操作有3种情况

337
00:13:07,800 --> 00:13:11,120
分别是要被删除的结点没有子结点

338
00:13:11,120 --> 00:13:13,560
要被删除的结点有一个子结点

339
00:13:13,560 --> 00:13:16,160
要被删除的结点有两个子结点

340
00:13:16,600 --> 00:13:17,960
我们结合例子

341
00:13:17,960 --> 00:13:20,120
从最简单的情况看起

342
00:13:20,520 --> 00:13:22,480
假设我们要删除 10

343
00:13:22,840 --> 00:13:26,280
我们发现 10 是个没有子结点的结点

344
00:13:26,680 --> 00:13:27,880
那么就很简单

345
00:13:27,880 --> 00:13:30,160
我们直接让他的父结点的右指针

346
00:13:30,160 --> 00:13:31,520
为空指针就行

347
00:13:32,240 --> 00:13:33,280
对于 Java 来说

348
00:13:33,280 --> 00:13:35,280
由于没有指针在指向 10

349
00:13:35,280 --> 00:13:38,000
Java 就会自动回收 10 这个结点

350
00:13:40,200 --> 00:13:42,600
接下来我们来看第二种情况

351
00:13:42,600 --> 00:13:44,280
假设我们要删除 8

352
00:13:44,840 --> 00:13:47,040
8 是个有一个子结点的值

353
00:13:47,040 --> 00:13:48,440
我们该怎么办呢

354
00:13:48,720 --> 00:13:50,440
请注意我们的删除目标

355
00:13:50,440 --> 00:13:53,240
我们要保持二叉搜索树的特征

356
00:13:53,560 --> 00:13:54,640
我们发现

357
00:13:54,880 --> 00:13:57,640
8 的子结点都是在 5 的右侧的

358
00:13:57,640 --> 00:13:58,560
也就是说

359
00:14:00,120 --> 00:14:01,240
8 的所有子结点都大于 5

360
00:14:01,440 --> 00:14:04,240
那么我们是否可以直接把 5 的右指针

361
00:14:04,240 --> 00:14:05,760
指向 8 的子结点呢

362
00:14:06,480 --> 00:14:07,480
当然可以

363
00:14:07,640 --> 00:14:08,760
而且这样一来

364
00:14:08,760 --> 00:14:11,720
8 也由于没有被引用而被回收了

365
00:14:12,080 --> 00:14:15,200
所以要删除一个有一个子结点的结点

366
00:14:15,200 --> 00:14:18,080
我们只需要让被删除结点的父结点

367
00:14:18,080 --> 00:14:19,920
指向它的子结点即可

368
00:14:20,440 --> 00:14:22,880
接下来我们来看最后一种情况

369
00:14:22,880 --> 00:14:24,400
假设我们要删除 5

370
00:14:24,400 --> 00:14:25,440
我们该怎么做

371
00:14:26,120 --> 00:14:28,280
脆鲨们可以暂停思考下

372
00:14:28,360 --> 00:14:30,440
七海5秒钟后揭晓答案

373
00:14:31,120 --> 00:14:34,320
54321

374
00:14:35,320 --> 00:14:37,480
首先我们知道要删除 5

375
00:14:37,480 --> 00:14:40,080
也就是要找一个已经存在在树里的值

376
00:14:40,080 --> 00:14:40,960
代替 5

377
00:14:41,240 --> 00:14:44,000
那么要找什么样的值来代替 5 呢

378
00:14:44,720 --> 00:14:47,120
这个值必须满足两个条件

379
00:14:47,120 --> 00:14:49,920
也就是二叉搜索树的定义

380
00:14:50,400 --> 00:14:52,080
这个值怎么找呢

381
00:14:52,160 --> 00:14:53,400
其实很简单

382
00:14:53,800 --> 00:14:55,000
我们可以把 5

383
00:14:55,000 --> 00:14:58,160
也就是被删除元素的左子树的最大值

384
00:14:58,160 --> 00:15:01,520
或者右子数的最小值作为新结点

385
00:15:01,840 --> 00:15:02,520
在例子中

386
00:15:02,520 --> 00:15:05,240
我们选择结点 6 来做替换

387
00:15:05,760 --> 00:15:08,320
然后我们再删除原来的 6 结点

388
00:15:08,880 --> 00:15:10,360
请注意删除原来的

389
00:15:10,360 --> 00:15:12,200
6 要么是情况一

390
00:15:12,200 --> 00:15:13,600
要么是情况二

391
00:15:13,920 --> 00:15:14,880
为什么呢

392
00:15:14,920 --> 00:15:17,080
因为如果它有两个子结点的话

393
00:15:17,080 --> 00:15:19,640
就不可能是右子数的最小值了

394
00:15:19,720 --> 00:15:21,280
那么要删除原来的

395
00:15:21,280 --> 00:15:23,560
6 我们再回到情况一二

396
00:15:23,560 --> 00:15:25,400
做删除操作即可

397
00:15:25,760 --> 00:15:28,320
那么让我们来做一个练习

398
00:15:28,320 --> 00:15:30,080
画出删除根结点后

399
00:15:30,080 --> 00:15:32,480
这个二叉搜索树的样子

400
00:15:32,880 --> 00:15:36,120
脆鲨们可以暂停，七海 5 秒后揭晓答案

401
00:15:36,480 --> 00:15:39,920
54321

402
00:15:41,520 --> 00:15:43,600
这就是答案的两个情况

403
00:15:45,600 --> 00:15:46,680
这节课的最后

404
00:15:46,680 --> 00:15:49,080
来看二叉搜索树的应用

405
00:15:49,680 --> 00:15:50,560
数据结构

406
00:15:50,560 --> 00:15:53,840
可以作为抽象数据类型的实现方式

407
00:15:54,200 --> 00:15:57,280
比如队列作为一种抽象数据类型

408
00:15:57,280 --> 00:16:00,200
它可以用链表这种数据结构实现

409
00:16:00,680 --> 00:16:01,560
那么接下来

410
00:16:01,560 --> 00:16:02,440
让我们看看

411
00:16:02,440 --> 00:16:06,040
二叉搜索树可以实现怎样的数据类型吧

412
00:16:06,400 --> 00:16:10,240
集合和字典就可以用二叉搜索树实现

413
00:16:10,680 --> 00:16:14,120
二叉搜索树不能有重复元素的特性

414
00:16:14,120 --> 00:16:16,840
满足了集合和字典的要求

415
00:16:17,080 --> 00:16:19,600
比如下图中的这个字符串集合

416
00:16:19,600 --> 00:16:22,200
就是用二叉搜索树实现的

417
00:16:22,480 --> 00:16:23,800
而字典的实现

418
00:16:23,800 --> 00:16:24,480
实际就是

419
00:16:24,480 --> 00:16:27,280
将二叉搜索树的结点存储的值

420
00:16:27,280 --> 00:16:28,920
改成了键值对

421
00:16:29,080 --> 00:16:30,960
那么这一节就讲完了

422
00:16:33,240 --> 00:16:35,600
这是七海第一次讲数据结构

423
00:16:35,600 --> 00:16:38,440
有不妥的地方各位可以在评论区指出

424
00:16:38,440 --> 00:16:39,880
还请大家谅解

425
00:16:40,320 --> 00:16:42,160
课程资料放在简介

426
00:16:42,320 --> 00:16:44,520
感兴趣的脆鲨可以查看

427
00:16:45,200 --> 00:16:46,320
谢谢大家！

428
00:06:45,400 --> 00:06:48,400
表示二叉树的类定义

429
00:11:38,400 --> 00:11:41,240
我们此时创建一个新结点

