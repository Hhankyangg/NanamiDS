1
00:00:00,200 --> 00:00:02,520
大家好我是七海Nanami

2
00:00:02,680 --> 00:00:05,520
今天七海给大家带来数据结构的课程

3
00:00:05,520 --> 00:00:08,400
今天的内容是平衡树和B树

4
00:00:08,840 --> 00:00:11,800
前置知识是上个视频的内容

5
00:00:12,120 --> 00:00:14,360
希望大家可以学有所获

6
00:00:14,840 --> 00:00:18,480
课程说明同上节课七海不再赘述

7
00:00:18,480 --> 00:00:20,560
还没有看过上节课的脆鲨

8
00:00:20,560 --> 00:00:22,280
可以到简介看链接

9
00:00:22,280 --> 00:00:24,200
或者进入up主的主页

10
00:00:24,480 --> 00:00:25,640
课程开始前

11
00:00:25,640 --> 00:00:26,640
七海想说

12
00:00:26,640 --> 00:00:28,240
七海现在也在学习中

13
00:00:28,240 --> 00:00:30,520
给大家讲的时候如果出现错误

14
00:00:30,520 --> 00:00:31,760
请脆鲨包含

15
00:00:31,760 --> 00:00:33,720
如果有错误请告诉我

16
00:00:33,840 --> 00:00:35,880
为了不浪费脆鲨们的时间

17
00:00:35,880 --> 00:00:37,920
这里有一些本节课的须知

18
00:00:37,920 --> 00:00:39,680
希望脆鲨仔细阅读后

19
00:00:39,680 --> 00:00:41,720
决定要不要观看本视频

20
00:00:45,720 --> 00:00:49,080
首先我们先来看看上节课预告的内容

21
00:00:49,080 --> 00:00:51,080
二叉搜索树的高度

22
00:00:51,560 --> 00:00:54,600
首先各位脆鲨需要知道一个树的概念

23
00:00:54,600 --> 00:00:55,760
一棵树的深度

24
00:00:55,760 --> 00:00:58,320
是这棵树所有结点中最远的一个

25
00:00:58,320 --> 00:01:00,360
结点距离根结点的边数

26
00:01:00,720 --> 00:01:03,240
而树的高度就是树的深度

27
00:01:03,680 --> 00:01:05,120
下面两幅图中

28
00:01:05,120 --> 00:01:08,360
二叉搜索树的高度都是 3

29
00:01:08,800 --> 00:01:12,160
对于右边这棵高度为3的二叉搜索树

30
00:01:12,160 --> 00:01:13,320
我们不难发现

31
00:01:13,320 --> 00:01:16,520
它的高度增长率是元素个数的对数

32
00:01:17,120 --> 00:01:20,120
这种树也是我们上节课反复提到的

33
00:01:20,120 --> 00:01:21,240
茂盛的树

34
00:01:21,520 --> 00:01:22,040
同时

35
00:01:22,040 --> 00:01:25,160
我们在右边也新建一个二叉搜索树

36
00:01:25,160 --> 00:01:26,440
根结点是 5

37
00:01:26,560 --> 00:01:29,480
接下来我往里面插入元素 6 7 8

38
00:01:29,760 --> 00:01:31,240
根据上节课的知识

39
00:01:31,240 --> 00:01:33,160
我们发现插入完成后

40
00:01:33,160 --> 00:01:35,080
这棵树成了这个样子……

41
00:01:35,720 --> 00:01:38,720
啊？这不就是个单向链表嘛

42
00:01:38,920 --> 00:01:42,040
这个实际是个单向链表的树的高度

43
00:01:42,040 --> 00:01:44,480
和数据量呈线性关系

44
00:01:44,720 --> 00:01:46,280
有脆鲨可能要问了

45
00:01:46,280 --> 00:01:47,160
这怎么了

46
00:01:47,200 --> 00:01:49,080
高度高有什么问题吗

47
00:01:49,360 --> 00:01:51,280
别忘了我们上节课提到过

48
00:01:51,280 --> 00:01:53,400
二叉搜索树的搜索操作

49
00:01:53,400 --> 00:01:56,200
最差情况就取决于树的高度

50
00:01:56,200 --> 00:01:59,160
而二叉搜索树别的操作又基于搜索

51
00:01:59,160 --> 00:02:00,000
由此高度

52
00:02:00,000 --> 00:02:02,040
是一个决定二叉搜索树的

53
00:02:02,040 --> 00:02:03,400
性能的重要因素

54
00:02:04,880 --> 00:02:08,600
那么二叉搜索树的高度又有哪些情况呢

55
00:02:08,800 --> 00:02:10,680
其实我们这页已经列出来了

56
00:02:10,680 --> 00:02:12,440
最佳情况是对数

57
00:02:12,440 --> 00:02:16,760
最坏情况直接成长度为 n 的单向链表

58
00:02:16,960 --> 00:02:18,200
我们总是希望

59
00:02:18,200 --> 00:02:20,600
我们的二叉搜索树是茂盛的

60
00:02:20,600 --> 00:02:22,680
因为这样可以在较低的高度

61
00:02:22,680 --> 00:02:24,440
放下较多的元素

62
00:02:24,440 --> 00:02:27,120
大大提高搜索等操作效率

63
00:02:27,360 --> 00:02:29,080
但是我们刚刚也看到了

64
00:02:29,080 --> 00:02:30,360
有些插入操作

65
00:02:30,360 --> 00:02:32,240
会让一棵树变得极端的高

66
00:02:32,240 --> 00:02:34,200
甚至退化成一个链表

67
00:02:34,720 --> 00:02:35,840
那么问题来了

68
00:02:35,840 --> 00:02:36,680
有没有办法

69
00:02:36,680 --> 00:02:39,360
可以让我们随心所欲地插入元素

70
00:02:39,360 --> 00:02:42,240
且一直能保持一棵树非常茂盛呢

71
00:02:42,560 --> 00:02:44,960
脆鲨也许很容易想到一个办法

72
00:02:44,960 --> 00:02:46,320
就是随机插入

73
00:02:46,640 --> 00:02:49,280
我拿到要插入的很多个元素

74
00:02:49,280 --> 00:02:50,840
先打乱再做插入

75
00:02:50,840 --> 00:02:53,680
是不是就能保证新的结点均匀分布

76
00:02:53,680 --> 00:02:55,840
最后整棵树都很茂盛呢？

77
00:02:56,040 --> 00:02:57,280
好消息是

78
00:02:57,400 --> 00:02:58,600
这是可以的

79
00:02:58,600 --> 00:03:00,600
打乱顺序插入元素

80
00:03:00,600 --> 00:03:01,960
可以大大降低

81
00:03:01,960 --> 00:03:04,440
树变成极端形状的可能性

82
00:03:04,680 --> 00:03:06,880
但是这个方法有局限性

83
00:03:07,400 --> 00:03:10,440
如果说我们的元素是一个一个获取的

84
00:03:10,920 --> 00:03:13,520
比如要记录一些事件的发生时间

85
00:03:13,520 --> 00:03:14,760
获取这些事件

86
00:03:14,760 --> 00:03:16,680
往往是一个一个获得的

87
00:03:16,920 --> 00:03:17,760
获取一个

88
00:03:17,760 --> 00:03:18,600
插入一个

89
00:03:18,600 --> 00:03:20,760
很容易就插入成了一个链表

90
00:03:21,160 --> 00:03:22,760
哪怕你说我先等等

91
00:03:22,760 --> 00:03:25,000
等我拿到几个元素后再打乱

92
00:03:25,000 --> 00:03:26,400
再一个一个插入

93
00:03:26,760 --> 00:03:28,160
是可以，但是

94
00:03:28,160 --> 00:03:31,440
一堆一堆元素之间也是有大小关系的

95
00:03:31,480 --> 00:03:33,400
哪怕你打乱了这 5 个元素

96
00:03:33,400 --> 00:03:36,240
下 5 个元素的所有数据都要比这 5 个大

97
00:03:36,240 --> 00:03:38,840
最终整棵树还是会趋向极端

98
00:03:39,280 --> 00:03:40,400
有没有一种办法

99
00:03:40,400 --> 00:03:42,280
让我们随便插入元素

100
00:03:42,320 --> 00:03:44,320
甚至是顺序序插入元素了

101
00:03:44,360 --> 00:03:46,920
树还是能维持在茂盛的状态呢

102
00:03:47,600 --> 00:03:48,600
有办法！

103
00:03:48,680 --> 00:03:53,040
这种办法就是建立在一种数据结构平衡树上的

104
00:03:53,320 --> 00:03:56,320
接下来我们来看看什么是平衡树吧

105
00:03:56,680 --> 00:04:00,040
平衡树是一种改进子二叉搜索树的

106
00:04:00,040 --> 00:04:03,240
为了实现更加高效的查询的一种树

107
00:04:03,520 --> 00:04:05,680
平衡树具有平衡性

108
00:04:05,800 --> 00:04:08,600
但是平衡性并没有一个统一的定义

109
00:04:08,600 --> 00:04:11,560
在各种不同的平衡树实现方式上

110
00:04:11,560 --> 00:04:13,480
平衡性的定义都不同

111
00:04:13,720 --> 00:04:15,440
但我们可以确定的是

112
00:04:15,440 --> 00:04:16,840
一般的平衡树

113
00:04:16,840 --> 00:04:19,680
都以我们此前提到的茂盛为目标

114
00:04:19,680 --> 00:04:21,360
也就是让这棵树的高度

115
00:04:21,360 --> 00:04:23,680
维持在元素数量的对数

116
00:04:24,000 --> 00:04:25,920
以此提高各种操作

117
00:04:25,920 --> 00:04:28,560
比如 查询 插入 删除 的效率

118
00:04:28,840 --> 00:04:30,360
为了得到一棵平衡树

119
00:04:30,360 --> 00:04:32,280
我们显然有两种方法

120
00:04:32,680 --> 00:04:35,600
第一种就是拿来一棵二叉搜索树

121
00:04:35,600 --> 00:04:36,880
对它进行操作

122
00:04:36,880 --> 00:04:39,000
调整它为一棵平衡树

123
00:04:39,280 --> 00:04:42,680
第二种就是从我们新建了一棵树开始

124
00:04:42,680 --> 00:04:44,360
在对树的各种操作中

125
00:04:44,360 --> 00:04:46,320
让树自动保持平衡

126
00:04:46,800 --> 00:04:48,360
比如我顺序插入时

127
00:04:48,400 --> 00:04:49,920
树意识到了不对劲

128
00:04:49,960 --> 00:04:51,760
就在我插入每个元素后

129
00:04:51,760 --> 00:04:53,600
自己调整自己的结构

130
00:04:53,600 --> 00:04:55,720
使自己变成一棵平衡树

131
00:04:55,960 --> 00:04:56,800
一般来说

132
00:04:56,800 --> 00:04:58,600
平衡树的实现方法

133
00:04:58,600 --> 00:05:00,680
都是为了实现自平衡的

134
00:05:00,680 --> 00:05:03,320
也就是用户只管插入删除就好

135
00:05:03,320 --> 00:05:05,880
树会自己侦测平衡是否被破坏

136
00:05:05,880 --> 00:05:07,640
然后做出相应的调整

137
00:05:07,640 --> 00:05:09,480
维持自己的平衡性

138
00:05:09,800 --> 00:05:11,600
这种自平衡的搜索树

139
00:05:11,600 --> 00:05:13,800
有很多不同的实现方式

140
00:05:13,800 --> 00:05:15,520
这节课我们就来了解一种

141
00:05:15,520 --> 00:05:18,240
以分裂为核心操作的树 B树

142
00:05:18,680 --> 00:05:22,400
下节课我们再讲 AVL树 和 红黑树

143
00:05:22,840 --> 00:05:25,360
首先我来以探索问题的方式

144
00:05:25,360 --> 00:05:27,280
让脆鲨们理解 B树

145
00:05:27,560 --> 00:05:29,400
假如我们已经有右图这样

146
00:05:29,400 --> 00:05:31,680
一棵平衡的二叉搜索树

147
00:05:31,680 --> 00:05:35,120
我们要依次插入元素 17 18 20

148
00:05:35,400 --> 00:05:37,280
如果就按老方法插入

149
00:05:37,280 --> 00:05:39,200
肯定会过度拉高高度

150
00:05:39,280 --> 00:05:41,080
那我们该怎么插入呢

151
00:05:41,360 --> 00:05:43,960
一个很直接也很疯狂的想法是

152
00:05:43,960 --> 00:05:45,480
既然不想让树变高

153
00:05:45,480 --> 00:05:47,680
那我干脆不再加新结点了

154
00:05:47,680 --> 00:05:49,960
这样树就永远不会长高了

155
00:05:50,280 --> 00:05:51,560
想法可以疯狂

156
00:05:51,560 --> 00:05:53,200
但前提是可行

157
00:05:53,560 --> 00:05:55,440
如果我们不再加入新结点

158
00:05:55,440 --> 00:05:57,640
新插入的元素放哪里呢

159
00:05:58,480 --> 00:06:00,400
我的答案就是 硬加

160
00:06:00,800 --> 00:06:01,280
是的

161
00:06:01,280 --> 00:06:03,840
我们强制往这个树的叶子结点里

162
00:06:03,840 --> 00:06:04,640
加元素

163
00:06:04,640 --> 00:06:07,520
让一个结点可以包含不止一个元素

164
00:06:07,920 --> 00:06:09,760
添加 17 好的

165
00:06:09,760 --> 00:06:12,400
我们就把 17 加到 16 的结点里

166
00:06:12,400 --> 00:06:14,440
并且放到 16 的右边

167
00:06:14,960 --> 00:06:18,080
18 和 20 的添加过程同理

168
00:06:18,440 --> 00:06:20,080
全部添加结束之后

169
00:06:20,080 --> 00:06:21,280
我们就获得了一个

170
00:06:21,280 --> 00:06:23,600
有四个元素的过载结点

171
00:06:24,000 --> 00:06:24,280
注意

172
00:06:24,280 --> 00:06:27,440
我们的添加依然保证着左小右大

173
00:06:27,440 --> 00:06:29,240
如果我最后要加入 19

174
00:06:29,240 --> 00:06:32,920
那么 19 应该放在 18 和 20 中间的位置

175
00:06:33,400 --> 00:06:35,080
我们在搜索 18 时

176
00:06:35,080 --> 00:06:38,760
也就仍然遵循二叉搜索树的搜索方式

177
00:06:39,240 --> 00:06:42,240
18 比 13 大，好的往右走

178
00:06:42,400 --> 00:06:44,880
18 比 15 大，好的往右走

179
00:06:45,280 --> 00:06:46,600
到了 16 的结点

180
00:06:46,600 --> 00:06:47,720
再一个一个比对

181
00:06:47,720 --> 00:06:49,120
就找到 18 了

182
00:06:49,400 --> 00:06:52,160
但是这个方法显然也有一些问题

183
00:06:52,320 --> 00:06:54,880
假如我们继续添加更大的元素

184
00:06:54,880 --> 00:06:58,200
这棵树将会有一个超长的叶子结点

185
00:06:58,400 --> 00:07:00,360
这样我们搜索一个树时

186
00:07:00,360 --> 00:07:02,960
很可能就要遍历整个超长结点

187
00:07:02,960 --> 00:07:03,880
才能找到

188
00:07:03,880 --> 00:07:06,000
这不就又效率低下了吗

189
00:07:06,240 --> 00:07:08,040
这下又该怎么办呢

190
00:07:08,720 --> 00:07:11,240
问题来了我们就一一解决

191
00:07:11,760 --> 00:07:14,680
既然不想让结点无限的承接元素

192
00:07:14,880 --> 00:07:17,840
那我们干脆设置一个限制值 L

193
00:07:18,160 --> 00:07:19,800
限制值是一个常数

194
00:07:19,800 --> 00:07:23,160
表示每个结点的数据量不能超过限制

195
00:07:23,360 --> 00:07:25,800
在这里我们设限制值为 3

196
00:07:26,120 --> 00:07:29,400
如果有结点元素数量超出限制值了

197
00:07:29,400 --> 00:07:30,680
怎么办呢

198
00:07:30,680 --> 00:07:33,360
我们扔一个元素到父结点就好了

199
00:07:33,800 --> 00:07:35,320
扔哪个元素呢

200
00:07:35,480 --> 00:07:38,280
七海在这规定扔中间的元素

201
00:07:38,320 --> 00:07:40,200
如果中间有两个元素

202
00:07:40,200 --> 00:07:42,440
我们就扔中间偏左的元素

203
00:07:42,840 --> 00:07:44,120
在右上的图中

204
00:07:44,120 --> 00:07:46,960
很明显有结点超过了限制值 3

205
00:07:47,080 --> 00:07:48,920
就把中间偏左的元素

206
00:07:48,920 --> 00:07:51,920
使其放置到父结点中 15 的右边

207
00:07:52,240 --> 00:07:54,520
那么这又带来一个全新的问题

208
00:07:54,520 --> 00:07:56,480
我们发现 17 上去了

209
00:07:56,480 --> 00:07:58,080
16 却还在下面

210
00:07:58,320 --> 00:08:00,040
接下来如果我们要找 16

211
00:08:00,040 --> 00:08:01,320
不就找不到了吗

212
00:08:01,320 --> 00:08:02,520
这该怎么办呢

213
00:08:02,760 --> 00:08:04,560
脆鲨可以暂停视频

214
00:08:04,560 --> 00:08:05,520
思考一下

215
00:08:05,520 --> 00:08:06,760
七海倒数 5 个数

216
00:08:06,760 --> 00:08:07,960
后揭晓答案

217
00:08:08,320 --> 00:08:11,240
5 4 3 2 1

218
00:08:12,200 --> 00:08:14,560
答案就是分裂结点

219
00:08:15,080 --> 00:08:18,480
我们把刚刚的结点沿着 17 的左右分开

220
00:08:18,480 --> 00:08:19,720
一边比 17 小

221
00:08:19,720 --> 00:08:21,080
一边比 17 大

222
00:08:21,640 --> 00:08:23,960
将左边的值作为一个结点

223
00:08:23,960 --> 00:08:25,880
插入到原来的父结点下

224
00:08:25,880 --> 00:08:28,680
注意这个操作没有改变树的高度

225
00:08:29,120 --> 00:08:32,080
现在父结点就有 3 个子结点了

226
00:08:32,440 --> 00:08:34,720
第一个装比 15 小的元素

227
00:08:34,720 --> 00:08:37,680
中间一个装 15 和 17 之间的元素

228
00:08:37,760 --> 00:08:40,240
最后一个装比 17 大的元素

229
00:08:40,600 --> 00:08:42,560
接下来我们在搜索 16 时

230
00:08:42,560 --> 00:08:43,360
就要注意看

231
00:08:43,360 --> 00:08:47,360
这个被搜索的元素是不是比 15 大比 17 小了

232
00:08:47,800 --> 00:08:48,640
到此为止

233
00:08:48,640 --> 00:08:49,880
我们改进的树中

234
00:08:49,880 --> 00:08:52,400
每个结点最多有 L 个元素

235
00:08:52,600 --> 00:08:54,720
那么当我们搜索一个元素时

236
00:08:54,720 --> 00:08:59,480
最差的时间复杂度是 O(L log N)

237
00:08:59,480 --> 00:09:01,160
由于限制值是常数

238
00:09:01,160 --> 00:09:02,080
可以忽略

239
00:09:02,320 --> 00:09:04,840
由此在这样一棵树中搜索

240
00:09:04,840 --> 00:09:08,840
最差时间复杂度仍然是 O(log N)

241
00:09:09,240 --> 00:09:11,760
为了检查脆鲨们有没有听懂

242
00:09:11,760 --> 00:09:13,920
七海出一道练习题给大家

243
00:09:14,280 --> 00:09:16,040
用我们刚刚介绍的策略

244
00:09:16,040 --> 00:09:20,000
对下面的树依次插入元素 20 和 21

245
00:09:20,280 --> 00:09:21,440
插入完成后

246
00:09:21,440 --> 00:09:23,440
这棵树变成了什么样呢

247
00:09:23,600 --> 00:09:25,600
脆鲨们可以画出来吗

248
00:09:25,840 --> 00:09:28,160
大家可以暂停视频思考

249
00:09:28,160 --> 00:09:30,000
七海 5 秒后揭晓答案

250
00:09:30,320 --> 00:09:33,240
5 4 3 2 1

251
00:09:34,120 --> 00:09:35,480
这就是插入过程

252
00:09:35,480 --> 00:09:36,800
结束后你会发现

253
00:09:36,800 --> 00:09:38,800
一个结点最多装 3 个值

254
00:09:38,800 --> 00:09:40,200
有 4 个子结点

255
00:09:42,200 --> 00:09:44,920
我们讲了叶子结点怎么分裂

256
00:09:45,040 --> 00:09:47,160
那如果我们往练习题这个树

257
00:09:47,160 --> 00:09:48,720
继续加入更大的值

258
00:09:48,720 --> 00:09:51,960
让非叶子结点的元素个数超出限制

259
00:09:52,000 --> 00:09:53,360
该怎么分裂呢

260
00:09:53,680 --> 00:09:55,320
非叶子结点要超载

261
00:09:55,320 --> 00:09:57,400
一定是它的子结点有分裂的

262
00:09:57,400 --> 00:10:00,640
传上来的一个元素导致父结点超载了

263
00:10:00,960 --> 00:10:03,120
这种现象像是连锁反应

264
00:10:03,120 --> 00:10:05,040
我们就叫它连锁分裂

265
00:10:05,520 --> 00:10:07,400
连锁分裂也是分裂

266
00:10:07,400 --> 00:10:09,880
不过是多个结点依次分裂罢了

267
00:10:10,000 --> 00:10:11,440
遵循的分裂规则

268
00:10:11,440 --> 00:10:14,440
和我们刚刚提到的叶结点分裂相同

269
00:10:14,720 --> 00:10:16,400
接下来我们就用一个例子

270
00:10:16,400 --> 00:10:18,960
来看看连锁分裂的过程吧

271
00:10:19,200 --> 00:10:21,760
在下面一棵 L 为 3 的树中

272
00:10:21,760 --> 00:10:24,800
依次插入元素 25 和 26

273
00:10:25,560 --> 00:10:28,320
加入 25 再加入 26 后

274
00:10:28,520 --> 00:10:30,960
右下角的叶子结点超载了

275
00:10:30,960 --> 00:10:33,360
接下来就执行它的分裂步骤

276
00:10:33,600 --> 00:10:35,480
21 向上走了

277
00:10:35,480 --> 00:10:37,040
20 被分出来了

278
00:10:37,240 --> 00:10:38,600
我们立刻发现

279
00:10:38,600 --> 00:10:40,520
因为 21 到了父结点

280
00:10:40,520 --> 00:10:42,480
导致父结点超载了

281
00:10:43,000 --> 00:10:43,760
那么接下来

282
00:10:43,760 --> 00:10:46,440
我们就要对父结点进行分裂操作

283
00:10:46,440 --> 00:10:49,040
依旧是选取中间偏左的元素

284
00:10:49,040 --> 00:10:50,040
也就是 17

285
00:10:50,040 --> 00:10:52,760
把它放到它的父结点对应的位置

286
00:10:53,360 --> 00:10:54,480
17 上去了

287
00:10:54,520 --> 00:10:56,880
原来结点中比 17 小的部分

288
00:10:56,880 --> 00:10:58,080
自然要分出来

289
00:10:58,600 --> 00:11:01,520
就这样我们完成了两个元素的插入

290
00:11:01,800 --> 00:11:03,960
这时候有的脆鲨可能要说了

291
00:11:03,960 --> 00:11:04,960
好的我知道了

292
00:11:04,960 --> 00:11:06,840
非叶子结点也能分裂

293
00:11:07,040 --> 00:11:08,480
那这么插入下去

294
00:11:08,480 --> 00:11:11,240
肯定会有根结点也超载的情况

295
00:11:11,600 --> 00:11:14,160
那根结点该怎么分裂呢

296
00:11:14,520 --> 00:11:17,520
下面我们再来看根结点怎么分裂

297
00:11:17,960 --> 00:11:20,040
看下面这棵 L 为 3 的树

298
00:11:20,040 --> 00:11:22,320
在进行一系列插入操作后

299
00:11:22,320 --> 00:11:24,160
根结点也超载了

300
00:11:24,360 --> 00:11:26,680
我们继续遵守分裂法则

301
00:11:26,840 --> 00:11:29,720
当我们试图把 17 往它的父结点放时

302
00:11:29,720 --> 00:11:30,440
可别忘了

303
00:11:30,440 --> 00:11:33,080
这是根结点已经没有父结点了

304
00:11:33,400 --> 00:11:34,400
这下好了

305
00:11:34,560 --> 00:11:35,320
事已至此

306
00:11:35,320 --> 00:11:37,400
就只能增加树的高度了

307
00:11:37,760 --> 00:11:40,560
于是我们让 17 成为了新的根结点

308
00:11:40,560 --> 00:11:43,040
其他结点也因此都下降了一层

309
00:11:43,320 --> 00:11:46,000
现在我们已经将这种分裂树的插入

310
00:11:46,000 --> 00:11:47,760
与分裂法则讲完了

311
00:11:47,760 --> 00:11:49,040
接下来测试一下

312
00:11:49,040 --> 00:11:49,760
各位脆鲨

313
00:11:49,760 --> 00:11:51,320
看大家有没有理解

314
00:11:51,720 --> 00:11:52,280
题目：

315
00:11:52,280 --> 00:11:55,000
向一符合我们刚刚讲到的分裂原则

316
00:11:55,000 --> 00:11:55,800
的空树中

317
00:11:55,800 --> 00:11:59,720
依次插入数字元素 1 2 3 4 5 6 7

318
00:12:00,160 --> 00:12:03,560
每个结点最多含有的元素数量为 2

319
00:12:03,560 --> 00:12:06,560
画出我们插入结束后树的样子

320
00:12:06,800 --> 00:12:08,800
脆鲨可以暂停思考

321
00:12:08,840 --> 00:12:10,800
七海 5 秒后揭晓答案

322
00:12:11,520 --> 00:12:14,440
5 4 3 2 1

323
00:12:16,080 --> 00:12:17,360
七海直接给出答案

324
00:12:17,360 --> 00:12:19,440
不太懂或者有问题的脆鲨

325
00:12:19,440 --> 00:12:20,440
可以倒回去

326
00:12:20,440 --> 00:12:23,040
重新看之前的插入方法讲解

327
00:12:23,040 --> 00:12:25,320
或者进入下面这个可视化网站

328
00:12:25,320 --> 00:12:26,160
自己试一下

329
00:12:26,160 --> 00:12:27,680
看看插入过程

330
00:12:27,840 --> 00:12:30,560
我们已经将我们一步一步探究出来的

331
00:12:30,560 --> 00:12:33,400
这种搜索数的插入和搜索操作

332
00:12:33,400 --> 00:12:34,920
介绍的很完备了

333
00:12:35,080 --> 00:12:37,440
接下来让我们一起来总结一下

334
00:12:37,760 --> 00:12:39,640
大家可以很直觉地感受到

335
00:12:39,640 --> 00:12:41,720
这种树的高度增长得很慢

336
00:12:41,720 --> 00:12:44,440
它的高度只会在一种情况下增长

337
00:12:44,440 --> 00:12:46,760
就是根结点超载时

338
00:12:46,920 --> 00:12:48,840
而根结点超载

339
00:12:48,840 --> 00:12:50,560
必定意味着有子结点也超载了

340
00:12:50,560 --> 00:12:51,880
刚刚才分裂完

341
00:12:52,040 --> 00:12:54,560
且根结点超载高度增加后

342
00:12:54,560 --> 00:12:57,720
所有非根结点都会向下加深一层

343
00:12:58,040 --> 00:12:58,880
讲了这么多了

344
00:12:58,880 --> 00:13:00,280
我们是时候揭晓了

345
00:13:00,280 --> 00:13:02,520
我们刚刚介绍的这种分裂树

346
00:13:02,520 --> 00:13:04,160
实际上就是B树

347
00:13:04,480 --> 00:13:05,880
建立一个B树

348
00:13:05,880 --> 00:13:06,480
需要指定

349
00:13:06,480 --> 00:13:09,400
每个结点最多能包含的值的数量

350
00:13:09,720 --> 00:13:11,200
但其实一般来说

351
00:13:11,200 --> 00:13:14,080
我们都将一个B树叫做几阶B树

352
00:13:14,120 --> 00:13:16,120
阶数就是指每个结点

353
00:13:16,120 --> 00:13:18,800
最多可以包含的子结点的个数

354
00:13:19,160 --> 00:13:22,080
今天我们例子中用到的 L 为 3 的树

355
00:13:22,080 --> 00:13:25,400
也叫做 2-3-4树 或者 2-4树

356
00:13:25,920 --> 00:13:26,760
意思就是

357
00:13:26,800 --> 00:13:30,760
一个结点可以有 2，3 或者 4 个子结点

358
00:13:31,120 --> 00:13:35,480
而 L = 2 的B树也可以被叫做 2-3树

359
00:13:35,840 --> 00:13:37,640
一个很有趣的事情是

360
00:13:37,640 --> 00:13:41,120
B树之所以叫B树并没有明确的解释

361
00:13:41,120 --> 00:13:44,760
发明者就这么叫了，那我们也就这么用了

362
00:13:45,360 --> 00:13:48,040
B树一般出现在以下两种情境

363
00:13:48,600 --> 00:13:50,160
L 比较小的 B树

364
00:13:50,160 --> 00:13:53,120
一般用来演示简单的平衡搜索树

365
00:13:53,120 --> 00:13:55,080
真实的应用并不常见

366
00:13:55,400 --> 00:13:58,520
而 L 比较大的树才被真实地应用

367
00:13:58,520 --> 00:14:01,440
它一般被用在操作系统的文件索引

368
00:14:01,440 --> 00:14:03,320
或者数据库的索引中

369
00:14:03,680 --> 00:14:06,760
上面我们提到B树就是一种平衡树

370
00:14:06,760 --> 00:14:08,640
但我们并没有仔细解释

371
00:14:08,640 --> 00:14:10,880
它的操作的时间复杂度

372
00:14:11,160 --> 00:14:12,280
但在解释前

373
00:14:12,280 --> 00:14:15,520
我们现在看两个非常重要的B树性质

374
00:14:15,520 --> 00:14:17,760
这有利于我们更深地了解B树

375
00:14:17,760 --> 00:14:19,800
与理解B树为什么平衡

376
00:14:21,160 --> 00:14:22,560
第一个性质是

377
00:14:22,560 --> 00:14:25,720
B树所有的叶子结点深度都相等

378
00:14:26,080 --> 00:14:28,960
这是因为我们提到过高度增加时

379
00:14:28,960 --> 00:14:31,520
所有结点都向下加深一层

380
00:14:31,520 --> 00:14:33,320
且第一次高度增加时

381
00:14:33,320 --> 00:14:36,800
就必定产生两个深度相同的叶子结点

382
00:14:37,200 --> 00:14:39,120
而根结点不分裂时

383
00:14:39,120 --> 00:14:40,240
无论怎么插入

384
00:14:40,240 --> 00:14:41,920
树的高度都不会变

385
00:14:42,280 --> 00:14:43,720
第二个性质是

386
00:14:43,720 --> 00:14:47,160
B树的一个有 n 个元素的非叶子结点

387
00:14:47,160 --> 00:14:49,480
一定有 n+1 个子结点

388
00:14:49,720 --> 00:14:52,320
各位脆鲨在这里可以暂停视频

389
00:14:52,320 --> 00:14:54,160
思考一下这两个性质

390
00:14:54,320 --> 00:14:55,560
试着去举反例

391
00:14:55,560 --> 00:14:58,040
然后你就会发现举不出来反例 :>

392
00:14:59,960 --> 00:15:01,240
利用这两个性质

393
00:15:01,240 --> 00:15:04,160
我们也可以判断一个树是不是B树

394
00:15:04,520 --> 00:15:07,880
比如下面这棵树同时违反了两个性质

395
00:15:07,880 --> 00:15:10,160
肯定不是一棵合法的B树

396
00:15:10,520 --> 00:15:12,160
用上面两个性质

397
00:15:12,160 --> 00:15:13,120
试着思考一下

398
00:15:13,120 --> 00:15:14,200
你认为所有的

399
00:15:14,200 --> 00:15:16,200
不平衡的树的可能的形状

400
00:15:16,200 --> 00:15:18,920
你会发现它们都肯定不是B树

401
00:15:19,240 --> 00:15:21,320
也可以利用上面两个性质

402
00:15:21,320 --> 00:15:24,520
感性地认知到B树一定是平衡的

403
00:15:24,840 --> 00:15:26,880
那么这节课的最后一部分

404
00:15:26,880 --> 00:15:29,440
就让我们看一下B树的性能

405
00:15:30,160 --> 00:15:33,800
分析B树插入和搜索操作的时间复杂度

406
00:15:34,200 --> 00:15:37,000
注意七海已经在本节课须知提到过

407
00:15:37,000 --> 00:15:38,080
这节课和以后

408
00:15:38,080 --> 00:15:40,600
都不会讲到B树的删除操作

409
00:15:40,600 --> 00:15:43,000
好奇的脆鲨可以自行搜索

410
00:15:43,000 --> 00:15:46,040
B树的删除操作也是很高效的

411
00:15:46,600 --> 00:15:48,480
搜索树操作的复杂度

412
00:15:48,480 --> 00:15:50,560
大多数取决于树的高度

413
00:15:50,600 --> 00:15:51,800
一般我们希望

414
00:15:51,800 --> 00:15:54,960
树的高度和元素个数是对数关系

415
00:15:54,960 --> 00:15:56,680
这样就能保证高效

416
00:15:57,120 --> 00:15:58,160
下面我们来看

417
00:15:58,160 --> 00:16:01,520
L = 2 的B树的两种高度情况

418
00:16:01,880 --> 00:16:05,880
最坏的情况是所有的结点只有一个值

419
00:16:06,280 --> 00:16:09,840
最好的情况是每个结点都有 L 个值

420
00:16:10,400 --> 00:16:11,840
这两种情况下

421
00:16:11,840 --> 00:16:15,200
高度都显然与元素个数呈对数关系

422
00:16:15,200 --> 00:16:17,080
只是底数不同罢了

423
00:16:17,400 --> 00:16:18,760
在渐进分析中

424
00:16:18,760 --> 00:16:20,520
我们可以舍弃底数

425
00:16:20,520 --> 00:16:21,800
那我们就可以得出

426
00:16:21,800 --> 00:16:25,760
B 树的高度就与元素个数呈对数关系

427
00:16:26,000 --> 00:16:28,560
L 不同时显然也成立

428
00:16:29,080 --> 00:16:32,840
了解了树的高度与元素个数呈对数关系

429
00:16:32,840 --> 00:16:36,040
查找的时间复杂度就很好理解了

430
00:16:36,320 --> 00:16:37,640
最坏的情况就是

431
00:16:37,640 --> 00:16:40,680
我们要搜索的元素在最最右下角

432
00:16:40,680 --> 00:16:42,640
此时我们需要查找

433
00:16:42,640 --> 00:16:44,040
h+1 个结点

434
00:16:44,360 --> 00:16:48,480
最多需要检查每个结点里 L 个元素

435
00:16:48,720 --> 00:16:51,400
那么整体的渐进时间复杂度

436
00:16:51,400 --> 00:16:53,920
上限就是 O(HL)

437
00:16:54,080 --> 00:16:56,320
我们知道 L 是一个常数

438
00:16:56,320 --> 00:16:57,360
可以被忽略

439
00:16:57,360 --> 00:17:01,840
所以查找的时间复杂度就是 O(log N)

440
00:17:02,320 --> 00:17:05,000
添加元素就更简单分析了

441
00:17:05,120 --> 00:17:07,680
添加一个元素肯定要先查找

442
00:17:07,960 --> 00:17:09,800
找到应该放的位置后

443
00:17:09,840 --> 00:17:11,920
最多分裂 H+1 次

444
00:17:11,960 --> 00:17:14,040
也就是让高度增长了

445
00:17:14,240 --> 00:17:17,760
而分裂操作在常数时间就能完成

446
00:17:17,760 --> 00:17:18,280
综上

447
00:17:18,280 --> 00:17:23,000
添加元素的时间复杂度也是 O(log N)

448
00:17:23,320 --> 00:17:25,560
那么第二节就讲完了

449
00:17:25,840 --> 00:17:27,400
谢谢各位脆鲨

450
00:17:27,680 --> 00:17:30,080
不知道各位脆鲨听懂了吗

451
00:17:30,120 --> 00:17:33,080
B树真是很棒的一种数据结构呢

452
00:17:33,280 --> 00:17:35,160
课程资料放在简介

453
00:17:35,320 --> 00:17:37,640
感兴趣的脆鲨可以查看

454
00:17:38,000 --> 00:17:40,960
下节课预计会是搜索树的最后一节

455
00:17:40,960 --> 00:17:43,680
内容是 AVL树 和 红黑树

456
00:17:44,120 --> 00:17:45,320
谢谢大家！

