1
00:00:00,200 --> 00:00:02,533
大家好我是七海娜娜米

2
00:00:02,766 --> 00:00:05,600
今天七海给大家带来数据结构的课程

3
00:00:05,600 --> 00:00:09,100
今天的内容是AVL树树和红黑树

4
00:00:09,566 --> 00:00:12,933
前置知识是上两个视频的内容

5
00:00:13,366 --> 00:00:15,600
希望大家可以学有所获

6
00:00:16,333 --> 00:00:18,333
课程说明同上节课

7
00:00:18,333 --> 00:00:20,400
没有看过上两节课的脆鲨

8
00:00:20,400 --> 00:00:22,300
可以到简介看到链接

9
00:00:22,300 --> 00:00:25,066
或者进入up主的主页看到视频

10
00:00:25,533 --> 00:00:27,333
为了不浪费脆鲨们的时间

11
00:00:27,333 --> 00:00:29,466
这里有一些本节课的须知

12
00:00:29,466 --> 00:00:31,200
希望脆鲨仔细阅读后

13
00:00:31,200 --> 00:00:33,266
决定要不要观看本视频

14
00:00:33,533 --> 00:00:34,966
本节课内容比较多

15
00:00:34,966 --> 00:00:36,600
课堂练习也比较多

16
00:00:36,733 --> 00:00:39,366
脆鲨们看到蓝色或紫色背景的页面

17
00:00:39,366 --> 00:00:42,100
就可以选择暂停视频思考了

18
00:00:42,533 --> 00:00:44,400
上节课我们讲到了B树

19
00:00:44,400 --> 00:00:46,800
B树是一种很棒的平衡树

20
00:00:46,866 --> 00:00:48,766
但是B树也有一些缺点

21
00:00:48,766 --> 00:00:49,933
其中一个就是

22
00:00:49,933 --> 00:00:52,866
B树的代码实现实在是太麻烦了

23
00:00:53,366 --> 00:00:56,733
B树一般需要维护不同类型的结点

24
00:00:56,733 --> 00:00:58,766
在插入删除等操作中

25
00:00:58,766 --> 00:01:01,333
结点类型会不断的发生变化

26
00:01:01,600 --> 00:01:02,566
下面的代码

27
00:01:02,566 --> 00:01:05,266
是一个2-3树的插入操作实现

28
00:01:05,266 --> 00:01:06,266
我们可以看到

29
00:01:06,266 --> 00:01:08,800
哪怕我们将抽象做到很极致

30
00:01:08,800 --> 00:01:11,533
代码实现依旧十分复杂和麻烦

31
00:01:12,066 --> 00:01:12,666
那么今天

32
00:01:12,666 --> 00:01:16,166
我们就来看一些别的平衡树实现方法

33
00:01:16,666 --> 00:01:19,133
今天我们讲到的两种平衡树

34
00:01:19,133 --> 00:01:21,666
都涉及到一种树的操作：旋转

35
00:01:22,200 --> 00:01:24,933
七海就先带大家来看看什么是

36
00:01:24,933 --> 00:01:27,533
二叉搜索树的旋转操作吧

37
00:01:27,866 --> 00:01:29,300
首先我们来看看

38
00:01:29,300 --> 00:01:32,500
旋转操作究竟能做到什么样的事情

39
00:01:32,966 --> 00:01:35,466
设想我们有一棵二叉搜索树

40
00:01:35,466 --> 00:01:37,966
包含三个元素 1 2 3

41
00:01:38,366 --> 00:01:40,200
根据插入顺序的不同

42
00:01:40,200 --> 00:01:42,966
我们有几种可能的树的结构呢

43
00:01:46,666 --> 00:01:48,133
根据插入顺序的不同

44
00:01:48,133 --> 00:01:49,366
我们能得到以下

45
00:01:49,366 --> 00:01:52,500
5 种不同结构的二叉搜索树

46
00:01:52,766 --> 00:01:54,833
更广泛来说，元素数量

47
00:01:54,866 --> 00:01:58,000
和它们可能组成的二叉搜索树的数量

48
00:01:58,000 --> 00:01:59,766
满足一种函数关系

49
00:01:59,766 --> 00:02:02,266
这种关系可以用卡塔兰数列表示

50
00:02:02,266 --> 00:02:04,700
感兴趣的脆鲨可以自行搜索

51
00:02:05,133 --> 00:02:06,133
回到正题

52
00:02:06,133 --> 00:02:07,333
旋转操作

53
00:02:07,333 --> 00:02:07,966
就是一种

54
00:02:07,966 --> 00:02:10,966
对二叉树结构进行改变的操作

55
00:02:11,300 --> 00:02:13,466
对二叉搜索树的某个结点

56
00:02:13,466 --> 00:02:15,133
进行旋转操作后

57
00:02:15,133 --> 00:02:16,600
树的结构会变化

58
00:02:16,600 --> 00:02:20,100
但仍保持自己是二叉搜索树的性质

59
00:02:20,466 --> 00:02:22,100
比如图中的 5 个结构

60
00:02:22,100 --> 00:02:24,666
我们可以用适合的旋转操作

61
00:02:24,666 --> 00:02:28,166
使得树的形态在 5 个结构中自由转换

62
00:02:28,533 --> 00:02:29,700
有论文证明

63
00:02:29,700 --> 00:02:33,100
n 个结点的不同形态的二叉搜索树间

64
00:02:33,100 --> 00:02:37,300
转换可以在 2n-6 个旋转操作内完成

65
00:02:37,733 --> 00:02:40,666
我们先了解了旋转操作能干什么

66
00:02:40,700 --> 00:02:42,566
接下来我们就举例来看看

67
00:02:42,566 --> 00:02:45,166
旋转操作是具体怎么操作的

68
00:02:45,266 --> 00:02:47,733
我们首先规定左旋操作

69
00:02:47,733 --> 00:02:49,333
将一个结点左旋

70
00:02:49,333 --> 00:02:51,266
就是让这个结点的右结点

71
00:02:51,266 --> 00:02:52,733
成为它的父结点

72
00:02:53,333 --> 00:02:55,300
例如我们现在要左旋 5

73
00:02:55,400 --> 00:02:58,800
那么 5 的右结点 9 就要成为 5 的父结点

74
00:02:58,966 --> 00:03:01,533
我们直接将 9 作为 5 的父结点

75
00:03:01,533 --> 00:03:02,700
因为 5 小于 9

76
00:03:02,700 --> 00:03:04,966
所以 5 肯定在 9 的左结点

77
00:03:05,266 --> 00:03:06,533
可是现在问题来了

78
00:03:06,533 --> 00:03:07,466
我们提到过

79
00:03:07,466 --> 00:03:10,000
旋转操作不会改变一棵树是

80
00:03:10,000 --> 00:03:12,066
二查搜索树的事实

81
00:03:12,566 --> 00:03:15,000
现在 5 成为了 9 的新左结点

82
00:03:15,000 --> 00:03:17,600
10 大于 9 依旧是 9 的右结点

83
00:03:17,733 --> 00:03:20,766
那 7 为根的这棵子树该去哪里呢

84
00:03:24,400 --> 00:03:25,066
我们注意到

85
00:03:25,066 --> 00:03:27,266
因为 9 成为了 5 的父结点

86
00:03:27,266 --> 00:03:29,366
5 的右结点就空出来了

87
00:03:29,733 --> 00:03:32,133
7 正好大于 5 小于 9

88
00:03:32,533 --> 00:03:35,500
所以放到 5 的右结点非常合适

89
00:03:35,900 --> 00:03:38,366
总结我们刚刚的左旋操作

90
00:03:38,366 --> 00:03:39,166
左旋 5

91
00:03:39,166 --> 00:03:42,200
就是让 5 的右结点成为了 5 的父结点

92
00:03:42,733 --> 00:03:45,800
那么多余出来的 9 的左结点刚好

93
00:03:45,800 --> 00:03:49,000
可以放到空出来的 5 的右结点的位置上

94
00:03:49,166 --> 00:03:52,133
这个旋转操作改变了树的形态

95
00:03:52,133 --> 00:03:53,700
增加了树的高度

96
00:03:53,766 --> 00:03:57,166
且这棵新的树仍然是依靠二叉搜索树

97
00:03:57,400 --> 00:03:58,600
如果各位脆鲨

98
00:03:58,600 --> 00:04:01,133
没太听懂刚刚的旋转操作

99
00:04:01,133 --> 00:04:04,133
也可以借助一部分B树的思想理解

100
00:04:04,533 --> 00:04:07,700
我们可以把左旋 5 理解成

101
00:04:07,700 --> 00:04:09,666
5 先和其右结点合并

102
00:04:09,666 --> 00:04:11,733
然后再把 5 分裂下去

103
00:04:12,000 --> 00:04:15,133
七海刚刚带大家看了左旋的操作过程

104
00:04:15,133 --> 00:04:16,800
接下来请脆鲨思考

105
00:04:16,800 --> 00:04:19,933
对图中这棵树的 9 结点进行右旋

106
00:04:19,933 --> 00:04:21,300
树会变成什么样

107
00:04:21,766 --> 00:04:22,966
一个小提示：

108
00:04:23,100 --> 00:04:24,600
将某结点左旋

109
00:04:24,600 --> 00:04:27,166
是让它的右结点成为父结点

110
00:04:27,566 --> 00:04:29,000
那么对称来看

111
00:04:29,200 --> 00:04:30,766
将某结点右旋

112
00:04:30,766 --> 00:04:33,500
就是让它的左结点成为父结点

113
00:04:37,366 --> 00:04:39,733
我们可以用合并的理解方式理解

114
00:04:39,733 --> 00:04:40,966
右旋操作

115
00:04:41,500 --> 00:04:43,966
9 和它的左结点 5 合并后

116
00:04:43,966 --> 00:04:45,566
自己再被分裂下来

117
00:04:45,866 --> 00:04:49,600
这个旋转操作和刚刚的左旋操作相反

118
00:04:49,600 --> 00:04:51,466
它增加了树的高度

119
00:04:51,700 --> 00:04:52,566
一般来说

120
00:04:52,566 --> 00:04:54,533
我们使用旋转操作

121
00:04:54,533 --> 00:04:57,300
都是为了让一棵树变成平衡树

122
00:04:57,800 --> 00:04:58,933
接下来我们就来看

123
00:04:58,933 --> 00:05:02,400
如何利用旋转操作平衡一棵树

124
00:05:02,900 --> 00:05:05,700
请各位脆鲨先思考下面这个问题

125
00:05:05,700 --> 00:05:07,666
该怎么进行旋转操作

126
00:05:07,666 --> 00:05:07,900
可以

127
00:05:07,900 --> 00:05:11,333
让左边这棵明显不平衡的二叉搜索树

128
00:05:11,333 --> 00:05:13,533
变成右边这样平衡的树

129
00:05:17,133 --> 00:05:19,566
七海给出一种操作方式

130
00:05:19,566 --> 00:05:21,666
实际操作方式有无数种

131
00:05:21,666 --> 00:05:22,700
但是七海这种

132
00:05:22,700 --> 00:05:25,266
是步数最少的一种操作方式

133
00:05:25,566 --> 00:05:27,333
首先我们将 3 右旋

134
00:05:27,333 --> 00:05:28,600
这个折线形的树

135
00:05:28,600 --> 00:05:30,133
变成了线形的树

136
00:05:30,133 --> 00:05:32,600
这个旋转操作不改变树高

137
00:05:33,066 --> 00:05:35,000
然后我们再将 1 左旋

138
00:05:35,000 --> 00:05:36,266
这一步减少树高

139
00:05:36,266 --> 00:05:38,166
树也变成了平衡树

140
00:05:38,400 --> 00:05:40,700
我们对单纯的旋转操作

141
00:05:40,700 --> 00:05:42,500
已经有了不少认知了

142
00:05:42,666 --> 00:05:45,366
我们知道左右旋怎么操作

143
00:05:45,366 --> 00:05:45,800
也知道了

144
00:05:45,800 --> 00:05:48,366
我们可以利用旋转平衡一棵树

145
00:05:48,366 --> 00:05:48,733
接下来

146
00:05:48,733 --> 00:05:51,933
我们就对旋转操作做简单的总结

147
00:05:52,466 --> 00:05:54,466
旋转可以改变树的高度

148
00:05:54,466 --> 00:05:56,466
也可能不改变树的高度

149
00:05:56,566 --> 00:05:57,000
而且

150
00:05:57,000 --> 00:06:00,533
旋转操作可以维持二叉搜索树的特性

151
00:06:00,533 --> 00:06:03,300
旋转后树仍是二叉搜索树

152
00:06:03,766 --> 00:06:07,566
这个图形形象地展示了左旋和右旋操作

153
00:06:07,600 --> 00:06:10,566
B 左边的三角表示 B 的左子树

154
00:06:10,566 --> 00:06:13,333
B 右边三角表示 B 的右子树

155
00:06:13,333 --> 00:06:16,500
D 右边的三角则表示 D 的右子树

156
00:06:16,733 --> 00:06:17,400
这样看来

157
00:06:17,400 --> 00:06:18,533
旋转操作

158
00:06:18,533 --> 00:06:21,733
实际上就是几个结点间指针的交换

159
00:06:22,200 --> 00:06:24,766
脆鲨请确保自己能看懂这张图

160
00:06:24,766 --> 00:06:25,666
如果有问题

161
00:06:25,666 --> 00:06:28,333
可以倒回去反复观看视频内容

162
00:06:28,366 --> 00:06:29,900
我们前面提到过

163
00:06:29,900 --> 00:06:31,700
n 个结点的不同形态

164
00:06:31,700 --> 00:06:33,200
二叉搜索树间

165
00:06:33,200 --> 00:06:36,966
可以在线性的旋转操作数下相互转换

166
00:06:37,400 --> 00:06:37,600
所以

167
00:06:37,600 --> 00:06:40,900
我们一定可以在 O(n) 的时间复杂度下

168
00:06:40,900 --> 00:06:43,666
平衡任何一棵二叉搜索树

169
00:06:44,100 --> 00:06:47,300
这里我们提一下旋转操作的代码实现

170
00:06:47,300 --> 00:06:48,333
我们刚刚提到

171
00:06:48,333 --> 00:06:49,300
旋转操作

172
00:06:49,300 --> 00:06:52,500
实际上只是几个结点间指针的交换

173
00:06:52,866 --> 00:06:55,100
我们的代码实现也是这样的

174
00:06:55,133 --> 00:06:56,400
拿右旋举例

175
00:06:56,400 --> 00:06:58,266
假如我们要右旋 A

176
00:06:58,266 --> 00:06:59,966
就得先暂存 B 结点

177
00:06:59,966 --> 00:07:02,000
因为 B 是新的根结点

178
00:07:02,366 --> 00:07:04,500
然后进行指针置换操作

179
00:07:04,566 --> 00:07:06,800
A 的左结点指向 T2

180
00:07:06,800 --> 00:07:08,600
B 的右结点指向 A

181
00:07:08,700 --> 00:07:11,366
最后让 A 的父结点指向暂存的 B

182
00:07:11,366 --> 00:07:12,800
就完成了旋转

183
00:07:12,933 --> 00:07:14,133
我们可以看到

184
00:07:14,133 --> 00:07:16,966
旋转操作需要的时间是常数

185
00:07:16,966 --> 00:07:18,966
具体的代码可以看链接

186
00:07:18,966 --> 00:07:20,966
链接也放到简介处了

187
00:07:21,400 --> 00:07:21,866
接下来

188
00:07:21,866 --> 00:07:24,166
七海邀请各位脆鲨和我一起来

189
00:07:24,166 --> 00:07:25,766
利用旋转操作

190
00:07:25,766 --> 00:07:28,200
将这棵树转换为平衡树

191
00:07:28,533 --> 00:07:31,366
脆鲨不用一眼看出该如何旋转

192
00:07:31,533 --> 00:07:32,966
只要跟着七海一起来看

193
00:07:32,966 --> 00:07:35,166
每一步都能理解就可以

194
00:07:35,566 --> 00:07:37,533
首先我们将 9 左旋

195
00:07:38,066 --> 00:07:39,166
左旋 9 之后

196
00:07:39,166 --> 00:07:41,733
我们得到了中间图中这棵树

197
00:07:43,300 --> 00:07:44,933
然后我们左旋 6

198
00:07:45,266 --> 00:07:47,366
这是左旋 6 的结果

199
00:07:47,366 --> 00:07:50,400
我们可以发现我们好像遇上熟人了

200
00:07:50,600 --> 00:07:51,600
8 的左子树

201
00:07:51,600 --> 00:07:54,500
就是我们刚刚遇到过的折线形树

202
00:07:54,733 --> 00:07:57,066
我们接下来左旋 1

203
00:07:57,533 --> 00:08:01,000
左旋1，8 的左子树变成了线形的树

204
00:08:01,400 --> 00:08:03,066
最后我们右旋 6

205
00:08:03,566 --> 00:08:06,666
右旋 6 后我们得到了一棵平衡树

206
00:08:07,200 --> 00:08:10,133
我们看到我们用了一系列旋转操作

207
00:08:10,133 --> 00:08:12,866
将一棵不平衡的二叉搜索树

208
00:08:12,866 --> 00:08:14,366
变成了平衡树

209
00:08:14,766 --> 00:08:16,100
难道这就够了吗？

210
00:08:16,100 --> 00:08:16,800
我们知道

211
00:08:16,800 --> 00:08:18,866
我们可以在 O(N) 的时间内

212
00:08:18,866 --> 00:08:21,200
平衡任意一棵二叉搜索树

213
00:08:21,200 --> 00:08:22,266
这就够了吗？

214
00:08:22,600 --> 00:08:23,333
显然不行

215
00:08:23,333 --> 00:08:24,700
在实际的应用中

216
00:08:24,700 --> 00:08:26,333
这样使用旋转操作

217
00:08:26,333 --> 00:08:28,566
来从头构建一棵平衡树

218
00:08:28,566 --> 00:08:29,866
没有什么太大的意义

219
00:08:29,866 --> 00:08:31,700
我们希望的是自平衡

220
00:08:31,966 --> 00:08:32,733
也就是说

221
00:08:32,733 --> 00:08:33,400
我们希望

222
00:08:33,400 --> 00:08:36,133
树在插入和删除操作的过程中

223
00:08:36,133 --> 00:08:37,966
自己保持自己的平衡

224
00:08:38,400 --> 00:08:39,333
那么接下来

225
00:08:39,333 --> 00:08:40,966
七海就向大家介绍一种

226
00:08:40,966 --> 00:08:44,666
以旋转操作为最核心操作的平衡树

227
00:08:44,666 --> 00:08:45,966
AVL树树

228
00:08:46,266 --> 00:08:49,966
AVL树树是第一种被发明出来的平衡树

229
00:08:49,966 --> 00:08:52,700
它在国内的很多数据结构教材中

230
00:08:52,700 --> 00:08:55,300
都是唯一一种被介绍的平衡树

231
00:08:55,900 --> 00:08:58,933
首先我们来看AVL树树的性质

232
00:08:59,066 --> 00:09:01,700
AVL树树有如下几个性质

233
00:09:01,966 --> 00:09:04,600
空二叉树是一个AVL树树

234
00:09:05,133 --> 00:09:07,266
如果 T 是一棵AVL树树

235
00:09:07,266 --> 00:09:10,333
那么它的左右子树都是AVL树树

236
00:09:10,366 --> 00:09:12,666
并且左右子树的高度差

237
00:09:12,666 --> 00:09:14,466
的绝对值小于等于一

238
00:09:14,533 --> 00:09:15,266
这个性质

239
00:09:15,266 --> 00:09:18,666
也就是AVL树树是平衡树的原因

240
00:09:19,366 --> 00:09:21,600
AVL树树作为一种平衡树

241
00:09:21,600 --> 00:09:24,100
它的高度是 O(log N)

242
00:09:24,333 --> 00:09:26,100
对于AVL树来说

243
00:09:26,100 --> 00:09:29,200
一个重要的概念叫做平衡因子

244
00:09:29,533 --> 00:09:32,366
平衡因子是对于结点而言的

245
00:09:32,466 --> 00:09:34,266
一个结点的平衡因子

246
00:09:34,266 --> 00:09:38,133
等于其右子树的高度减左子树的高度

247
00:09:38,666 --> 00:09:41,300
这种树我们在操作中维持平衡

248
00:09:41,300 --> 00:09:43,200
靠的就是平衡因子

249
00:09:43,400 --> 00:09:47,300
我们在向一棵AVL树中插入元素时

250
00:09:47,300 --> 00:09:48,766
每插入一个元素

251
00:09:48,766 --> 00:09:51,566
这个元素到根结点的所有结点

252
00:09:51,566 --> 00:09:53,566
平衡因子都会变化

253
00:09:53,966 --> 00:09:55,966
如果我们插入一个元素后

254
00:09:56,066 --> 00:09:58,533
沿插入结点到根结点检查

255
00:09:58,533 --> 00:09:58,933
发现

256
00:09:58,933 --> 00:10:02,000
有结点的平衡因子绝对值大于一了

257
00:10:02,000 --> 00:10:04,966
我们就要进行适当的旋转操作了

258
00:10:05,166 --> 00:10:07,700
比如例子中我们插入了 2 后

259
00:10:07,700 --> 00:10:11,066
根结点的平衡因子绝对值大于一了

260
00:10:11,666 --> 00:10:14,700
这种折线形的不平衡树旋转方法

261
00:10:14,700 --> 00:10:16,300
我们已经深植于心了

262
00:10:16,300 --> 00:10:18,700
两步旋转后即可平衡

263
00:10:19,000 --> 00:10:22,300
AVL树的插入操作和删除操作

264
00:10:22,300 --> 00:10:24,866
都与普通的二叉搜索树类似

265
00:10:24,866 --> 00:10:27,966
不过是在之后加上了检查平衡因子

266
00:10:27,966 --> 00:10:31,066
再根据平衡因子做旋转的操作

267
00:10:31,500 --> 00:10:32,766
所以我们可以看到

268
00:10:32,766 --> 00:10:36,100
AVL树不过就是一般的二叉搜索树

269
00:10:36,100 --> 00:10:38,200
带上了平衡因子这个概念

270
00:10:38,200 --> 00:10:40,700
以便它可以在插入删除操作中

271
00:10:40,700 --> 00:10:43,133
通过旋转实现自平衡

272
00:10:43,566 --> 00:10:45,466
大家可以在下面的链接中

273
00:10:45,466 --> 00:10:48,700
动态的尝试AVL树的操作过程

274
00:10:48,700 --> 00:10:50,666
链接同样放在简介

275
00:10:51,133 --> 00:10:54,133
七海对AVL树的讲解就到这里

276
00:10:54,133 --> 00:10:54,700
实际上

277
00:10:54,700 --> 00:10:57,766
七海已经将核心操作介绍的十分完备

278
00:10:58,100 --> 00:10:59,933
操作的细节没有涉及到

279
00:10:59,933 --> 00:11:02,666
脆鲨们掌握了七海目前提到的内容

280
00:11:02,666 --> 00:11:03,766
再自己去搜索

281
00:11:03,766 --> 00:11:05,866
一定就能很容易的看懂了

282
00:11:06,166 --> 00:11:08,533
对于脆鲨们可能有的一些疑问

283
00:11:08,533 --> 00:11:09,700
七海做了预判

284
00:11:09,700 --> 00:11:10,733
并放在这里

285
00:11:10,733 --> 00:11:12,700
脆鲨们可以进行查看

286
00:11:16,200 --> 00:11:17,766
讲完了AVL树

287
00:11:17,766 --> 00:11:20,400
接下来就是我们这节课的重头戏了

288
00:11:20,400 --> 00:11:22,133
红黑树

289
00:11:22,133 --> 00:11:24,966
小提示：下面的树的结点中的元素

290
00:11:24,966 --> 00:11:26,366
可能不再是数字

291
00:11:26,366 --> 00:11:27,366
而是字母

292
00:11:27,933 --> 00:11:29,500
字母的大小关系

293
00:11:29,500 --> 00:11:31,866
就是其在字母表中的顺序

294
00:11:31,900 --> 00:11:33,333
后面大前面小

295
00:11:33,333 --> 00:11:33,700
或者

296
00:11:33,700 --> 00:11:37,000
也可理解为其对应的 ACSII 码的大小

297
00:11:37,333 --> 00:11:38,133
迄今为止

298
00:11:38,133 --> 00:11:39,766
我们学习了两种树

299
00:11:39,766 --> 00:11:41,566
一种是AVL树

300
00:11:41,566 --> 00:11:44,366
是一种利用旋转的自平衡树

301
00:11:44,900 --> 00:11:45,966
一种是B树

302
00:11:45,966 --> 00:11:47,600
是一种没有利用旋转

303
00:11:47,600 --> 00:11:50,166
而是利用了分裂操作的搜索树

304
00:11:50,166 --> 00:11:51,533
它不是二叉树

305
00:11:51,533 --> 00:11:53,200
但是具有平衡性

306
00:11:53,666 --> 00:11:55,866
我们在这介绍一种新的想法

307
00:11:55,866 --> 00:11:58,600
既然B树实现困难的原因之一是

308
00:11:58,600 --> 00:11:59,966
它不是二叉树

309
00:11:59,966 --> 00:12:01,933
所以结点类型不固定

310
00:12:02,500 --> 00:12:04,800
那我们能不能用二叉搜索树

311
00:12:04,800 --> 00:12:06,600
去表示一棵2-3树

312
00:12:06,600 --> 00:12:08,566
使得两者的结构等价

313
00:12:08,900 --> 00:12:11,400
这样因为2-3树是平衡的

314
00:12:11,400 --> 00:12:11,700
所以

315
00:12:11,700 --> 00:12:15,466
我们的特殊的二叉搜索树也是平衡的

316
00:12:15,700 --> 00:12:18,733
那我们该如何用一棵二叉搜索树

317
00:12:18,733 --> 00:12:20,700
表示一棵2-3树呢

318
00:12:21,100 --> 00:12:21,733
对于一棵

319
00:12:21,733 --> 00:12:24,700
所有结点只有一个元素的2-3树

320
00:12:24,700 --> 00:12:28,000
它的二叉树表示方法就是它本身

321
00:12:28,333 --> 00:12:31,366
但是对于一棵有过载结点的2-3树

322
00:12:31,366 --> 00:12:34,866
它的最应的二叉树应该怎么表示呢

323
00:12:35,300 --> 00:12:36,300
一个想法是

324
00:12:36,300 --> 00:12:39,066
我们可以用一个连接结点作为过渡

325
00:12:39,066 --> 00:12:40,266
如图所示

326
00:12:40,666 --> 00:12:42,966
这样过载结点就被分成了

327
00:12:42,966 --> 00:12:45,333
连接结点的两个子结点

328
00:12:45,866 --> 00:12:48,166
但是这样解决问题是不优雅的

329
00:12:48,166 --> 00:12:49,266
因为我们发现

330
00:12:49,266 --> 00:12:51,666
原来过载结点的三个子结点

331
00:12:51,666 --> 00:12:53,733
现在被分给了两个父结点

332
00:12:53,733 --> 00:12:55,966
势必会造成边数的浪费

333
00:12:56,166 --> 00:12:57,533
那我们换一个想法

334
00:12:57,533 --> 00:12:59,900
把连接结点变成连接边

335
00:13:00,533 --> 00:13:03,566
在过载结点的两个元素间添加一个边

336
00:13:03,566 --> 00:13:04,900
将较小

337
00:13:04,900 --> 00:13:06,900
的元素们放到左边

338
00:13:07,300 --> 00:13:10,800
注意放左边只是七海在这里规定的

339
00:13:10,800 --> 00:13:12,966
实际上也可以用连接边

340
00:13:12,966 --> 00:13:15,366
将较大的元素放在右边

341
00:13:15,600 --> 00:13:18,666
这种方法看上去就更加优雅了

342
00:13:19,333 --> 00:13:20,900
为了方便我们分析

343
00:13:20,900 --> 00:13:24,200
我们将这些连接边标记为红色

344
00:13:24,333 --> 00:13:26,566
其他的边就是黑色边

345
00:13:27,000 --> 00:13:28,866
这种连接边的思想

346
00:13:28,866 --> 00:13:30,800
在实践中很常被用到

347
00:13:30,800 --> 00:13:33,500
比如 java 的树状集合类的实现

348
00:13:33,500 --> 00:13:34,933
就用了这种思想

349
00:13:35,333 --> 00:13:36,766
在代码的实现中

350
00:13:36,766 --> 00:13:39,166
因为我们可能不方便实现边（的颜色）

351
00:13:39,300 --> 00:13:39,566
所以

352
00:13:39,566 --> 00:13:42,933
我们可以用结点的颜色表示边的颜色

353
00:13:43,133 --> 00:13:45,933
我们可以在结点的实例变量中

354
00:13:45,933 --> 00:13:48,166
添加一个表示颜色的变样

355
00:13:48,166 --> 00:13:48,966
这个颜色

356
00:13:48,966 --> 00:13:50,300
就表示父结点

357
00:13:50,300 --> 00:13:52,600
指向这个结点的变的颜色

358
00:13:53,100 --> 00:13:57,500
上面这种用左连接边表示2-3树的二叉搜索树

359
00:13:57,600 --> 00:13:59,766
被称作左偏红黑树

360
00:14:00,066 --> 00:14:03,766
左偏红黑树是红黑树的一种简单变体

361
00:14:03,866 --> 00:14:05,900
在这节课程的余下内容中

362
00:14:05,900 --> 00:14:08,200
我们主要介绍左偏红黑树

363
00:14:08,666 --> 00:14:12,100
左偏红黑树有几个最基本的性质

364
00:14:12,666 --> 00:14:13,466
首先

365
00:14:13,466 --> 00:14:16,666
左偏红黑树就是一种二叉搜索树

366
00:14:16,666 --> 00:14:18,133
所以它的搜索操作

367
00:14:18,133 --> 00:14:20,966
和普通的二叉搜索树一模一样

368
00:14:21,300 --> 00:14:25,866
其次左偏红黑树与2-3树有一一对应的关系

369
00:14:26,366 --> 00:14:27,100
也就是说

370
00:14:27,100 --> 00:14:28,733
一棵左偏红黑树

371
00:14:28,733 --> 00:14:31,133
有唯一一棵2-3树与之对应

372
00:14:31,200 --> 00:14:32,533
反之也成立

373
00:14:32,533 --> 00:14:34,400
这也就是双射关系

374
00:14:34,700 --> 00:14:35,100
最后

375
00:14:35,100 --> 00:14:38,700
红色边黑色边只是起到标注的作用

376
00:14:38,700 --> 00:14:41,533
不会对树的结构起到改变性的作用

377
00:14:41,533 --> 00:14:42,500
时刻记住

378
00:14:42,500 --> 00:14:45,766
左偏红黑树就是一种二叉搜索树

379
00:14:46,333 --> 00:14:48,866
为了更深刻的理解左偏红黑树

380
00:14:48,866 --> 00:14:49,766
我们接下来

381
00:14:49,766 --> 00:14:53,000
来看左偏红黑树的一些很重要的性质

382
00:14:53,000 --> 00:14:54,966
来加深我们对它的理解

383
00:14:55,366 --> 00:14:57,666
接下来我们要做很多练习

384
00:14:57,966 --> 00:15:00,866
请各位脆鲨做好准备首

385
00:15:00,866 --> 00:15:02,566
先请脆鲨们画出

386
00:15:02,566 --> 00:15:06,500
与下面这棵2-3树对应的左偏红黑树

387
00:15:10,466 --> 00:15:11,266
答案如下

388
00:15:11,266 --> 00:15:14,266
我们用红色边分开过载结点

389
00:15:14,266 --> 00:15:15,100
时刻记住

390
00:15:15,100 --> 00:15:16,933
这是左偏红黑树

391
00:15:16,933 --> 00:15:19,400
红色边只能是左偏的

392
00:15:19,766 --> 00:15:21,966
接下来我们来看一道难题

393
00:15:22,500 --> 00:15:25,133
在下面的 4 个左偏红黑树中

394
00:15:25,300 --> 00:15:26,900
哪个是合法的

395
00:15:27,266 --> 00:15:28,666
小提示：因为

396
00:15:28,666 --> 00:15:30,366
左偏红黑树和2-3树

397
00:15:30,366 --> 00:15:32,733
有一一对应的关系

398
00:15:32,900 --> 00:15:36,433
所以我们可以把这些树转换为2-3树再研究

399
00:15:36,500 --> 00:15:38,366
化未知为已知

400
00:15:42,400 --> 00:15:45,566
我们把这四个数都转换成2-3树

401
00:15:46,000 --> 00:15:49,100
第一个2-3树有结点超载了

402
00:15:49,100 --> 00:15:51,066
这种有三个元素的结点

403
00:15:51,066 --> 00:15:53,100
只能在中间态出现

404
00:15:53,166 --> 00:15:56,366
对于一棵2-3树来说是不合法的

405
00:15:56,800 --> 00:15:59,466
第二个2-3树有很多问题

406
00:15:59,600 --> 00:16:02,900
首先 AB 结点应该有 3 个子结点

407
00:16:02,900 --> 00:16:06,200
其次叶结点应该都在同一层才对

408
00:16:06,200 --> 00:16:07,700
图二也不合法

409
00:16:08,100 --> 00:16:11,200
第三个2-3树的问题在于

410
00:16:11,466 --> 00:16:13,166
叶结点不在同一层

411
00:16:13,166 --> 00:16:14,133
不合法

412
00:16:14,766 --> 00:16:17,400
最后一个2-3树是合法的

413
00:16:17,566 --> 00:16:21,400
所以它对应的左偏红黑树也是合法的

414
00:16:21,400 --> 00:16:24,466
我们再来看一道关于树的高度的题目

415
00:16:24,466 --> 00:16:27,900
下面这棵2-3树所对应的左偏红黑树

416
00:16:27,900 --> 00:16:29,100
高度是多少

417
00:16:32,866 --> 00:16:33,866
我们很容易找到

418
00:16:33,866 --> 00:16:36,466
对应的左偏红黑树

419
00:16:36,466 --> 00:16:38,266
边数最多的一条路径

420
00:16:38,266 --> 00:16:41,133
就是过载结点最多的一条路径

421
00:16:41,366 --> 00:16:42,466
我们可以得到

422
00:16:42,466 --> 00:16:47,300
高度就是三条黑边加两条红边等于 5

423
00:16:47,733 --> 00:16:50,300
接下来我们看一道关于高度的难题

424
00:16:50,300 --> 00:16:53,133
假设一棵2-3树的高度为 H

425
00:16:53,500 --> 00:16:55,733
那它对应的左偏红黑树

426
00:16:55,733 --> 00:16:57,300
最大高度是多少

427
00:17:01,266 --> 00:17:02,300
为了高度高

428
00:17:02,300 --> 00:17:04,500
我们就要尽力在一条路径上

429
00:17:04,500 --> 00:17:06,266
放满过载结点

430
00:17:06,666 --> 00:17:07,466
比如例子中

431
00:17:07,466 --> 00:17:10,066
我们就在2-3树的一条路径上

432
00:17:10,066 --> 00:17:11,766
放满了过载结点

433
00:17:12,200 --> 00:17:13,133
这样一来

434
00:17:13,133 --> 00:17:14,533
左偏红黑树

435
00:17:14,533 --> 00:17:18,266
的高度就有最大值为 2H+1

436
00:17:18,533 --> 00:17:19,333
我们知道

437
00:17:19,533 --> 00:17:22,700
2-3树的高度是 O(log N)

438
00:17:23,133 --> 00:17:24,366
而与其对应的

439
00:17:24,366 --> 00:17:27,200
相同元素数量的左偏红黑树

440
00:17:27,200 --> 00:17:29,933
高度约为2-3树高度的两倍

441
00:17:29,933 --> 00:17:34,000
所以左偏红黑树的高度也是 O(log N)

442
00:17:34,400 --> 00:17:36,800
这也就更加严谨的证明了

443
00:17:36,900 --> 00:17:39,200
左偏红黑树是平衡的

444
00:17:39,733 --> 00:17:41,266
综合上面几道题目

445
00:17:41,266 --> 00:17:45,000
七海给出左偏红黑树的两个重要性质

446
00:17:45,266 --> 00:17:49,566
一，不可能有一个结点有两条红色边

447
00:17:50,200 --> 00:17:53,266
因为如果有结点有两个红色边

448
00:17:53,366 --> 00:17:55,400
那它对应的2-3树

449
00:17:55,400 --> 00:17:57,400
就会有一个三元素结点

450
00:17:57,400 --> 00:17:58,500
这是不行的

451
00:17:59,266 --> 00:18:00,333
二，从根结点

452
00:18:00,333 --> 00:18:03,400
到每个叶结点的所有简单路径上

453
00:18:03,400 --> 00:18:06,066
都包含相同数目的黑色边

454
00:18:06,366 --> 00:18:09,533
这个性质对应了2-3树的一个性质

455
00:18:09,533 --> 00:18:12,166
所有叶子结点都在同一层

456
00:18:12,466 --> 00:18:13,733
不理解这些性质

457
00:18:13,733 --> 00:18:17,133
的脆鲨可以暂停视频仔细思考一下

458
00:18:17,133 --> 00:18:19,533
或者去复习下B树的视频

459
00:18:20,066 --> 00:18:21,300
知道了性质之后

460
00:18:21,300 --> 00:18:23,566
再看我们刚刚做过的这个题

461
00:18:23,600 --> 00:18:26,566
就不用转化为2-3树再分析了

462
00:18:26,933 --> 00:18:29,300
对着性质直接分析即可

463
00:18:29,500 --> 00:18:30,933
七海不再赘述

464
00:18:31,066 --> 00:18:34,333
我们深入理解了左偏红黑树的性质

465
00:18:34,566 --> 00:18:35,866
接下来我们来看看

466
00:18:35,866 --> 00:18:39,300
一棵左偏红黑树是怎么被构建起来的

467
00:18:39,666 --> 00:18:43,466
一个重要的问题：左偏红黑树从哪里来

468
00:18:43,566 --> 00:18:45,000
脆鲨们可不要告诉我

469
00:18:45,000 --> 00:18:46,800
先创建一棵2-3树

470
00:18:46,800 --> 00:18:48,900
再从2-3树转换而来

471
00:18:48,966 --> 00:18:51,800
我们应该从一棵空树开始插入

472
00:18:51,800 --> 00:18:55,066
在插入中实现一棵左偏红黑树

473
00:18:55,600 --> 00:18:56,900
左偏红黑树

474
00:18:56,900 --> 00:18:59,400
插入操作遵循如下的策略

475
00:18:59,766 --> 00:19:00,366
首先

476
00:19:00,366 --> 00:19:04,366
像插入一般的二叉搜索树一样进行插入

477
00:19:04,700 --> 00:19:07,266
然后再利用旋转等操作

478
00:19:07,266 --> 00:19:11,433
保证左偏红黑树与2-3树的一一对应关系

479
00:19:12,000 --> 00:19:14,333
接下来我们就以解决问题的形式

480
00:19:14,333 --> 00:19:16,900
一起来研究一下这里的操作吧

481
00:19:17,100 --> 00:19:19,133
问题一：我们在插入时

482
00:19:19,133 --> 00:19:20,866
应该用什么颜色的边

483
00:19:21,466 --> 00:19:23,300
注意我们的研究策略

484
00:19:23,400 --> 00:19:26,733
既然要维持和2-3树的一一对应关系

485
00:19:26,733 --> 00:19:28,933
我们就要看看相同的插入

486
00:19:28,933 --> 00:19:31,166
在2-3树中是怎么做的

487
00:19:31,400 --> 00:19:32,533
虚线上方

488
00:19:32,533 --> 00:19:36,200
是我们要探究的左偏红黑树插入方式

489
00:19:36,200 --> 00:19:39,366
下方则是2-3树的插入方式

490
00:19:42,866 --> 00:19:44,533
这个问题答案很明显

491
00:19:44,533 --> 00:19:46,700
我们应该用红色的边插入

492
00:19:46,700 --> 00:19:48,300
因为2-3树的插入

493
00:19:48,300 --> 00:19:50,933
都是默认不产生新结点的

494
00:19:51,333 --> 00:19:54,300
问题二：在下面的树中插入元素

495
00:19:54,300 --> 00:19:57,066
假设我们加入的元素处于右结点

496
00:19:57,066 --> 00:19:57,866
按照规则

497
00:19:57,866 --> 00:19:59,533
我们应该使用红边

498
00:19:59,600 --> 00:20:01,800
但这样违反了左偏的规则

499
00:20:01,800 --> 00:20:02,800
该怎么办呢

500
00:20:06,166 --> 00:20:09,333
这时候旋转操作就派上用场了

501
00:20:09,666 --> 00:20:10,400
在例子中

502
00:20:10,400 --> 00:20:12,966
我们左旋插入元素的父结点

503
00:20:12,966 --> 00:20:14,300
也就是 7

504
00:20:14,300 --> 00:20:16,566
来保证红色边的左偏

505
00:20:17,200 --> 00:20:19,666
问题三：假如我们插入的元素

506
00:20:19,666 --> 00:20:23,300
造成了如下两个相邻红边出现的情况

507
00:20:23,300 --> 00:20:24,366
该怎么办呢

508
00:20:24,600 --> 00:20:27,066
这是一道比较困难的思考题

509
00:20:27,333 --> 00:20:27,666
所以

510
00:20:27,666 --> 00:20:30,666
脆鲨可以从2-3树的角度思考结果

511
00:20:30,666 --> 00:20:32,733
再想办法靠近结果

512
00:20:36,400 --> 00:20:39,000
首先对于2-3树来说

513
00:20:39,000 --> 00:20:40,566
是时候分裂了

514
00:20:41,000 --> 00:20:43,133
2-3树分裂之后的结果

515
00:20:43,133 --> 00:20:45,400
再转换为左偏红黑树

516
00:20:45,400 --> 00:20:48,133
就是我们想要我们的左偏红黑树

517
00:20:48,133 --> 00:20:50,266
最终旋转成的样子

518
00:20:50,333 --> 00:20:51,600
我们知道了答案

519
00:20:51,600 --> 00:20:52,466
就得想办法

520
00:20:52,466 --> 00:20:55,200
我们的左偏红黑树怎么操作

521
00:20:55,200 --> 00:20:57,066
才能成为答案的样子呢

522
00:20:57,533 --> 00:20:59,733
实际上我们需要两步操作

523
00:21:00,133 --> 00:21:01,800
第一步我们先右旋 4

524
00:21:01,800 --> 00:21:03,400
使得旋转后

525
00:21:03,400 --> 00:21:05,966
结点下有两个红色的子边

526
00:21:06,500 --> 00:21:09,100
实际上我们也可能在插入过程中

527
00:21:09,200 --> 00:21:12,366
直接得到一个结点有两个红色的子边的情况

528
00:21:12,366 --> 00:21:15,300
比如我们最后插入的不是 2

529
00:21:15,300 --> 00:21:16,366
而是 5 

530
00:21:16,366 --> 00:21:19,166
第二步操作就不是旋转操作了

531
00:21:19,166 --> 00:21:21,100
而是颜色翻转操作

532
00:21:21,100 --> 00:21:22,966
对 3 进行颜色翻转

533
00:21:22,966 --> 00:21:25,733
此时 3 下面的两条红边变黑

534
00:21:25,733 --> 00:21:27,466
上面的一条边变红

535
00:21:27,900 --> 00:21:29,966
这一步实际上可以理解为

536
00:21:29,966 --> 00:21:33,466
2-3树分裂操作中的向上分裂步骤

537
00:21:33,700 --> 00:21:35,500
就这样我们解决了问题三

538
00:21:35,500 --> 00:21:37,166
好消息是

539
00:21:37,166 --> 00:21:38,766
我们上面的三个问题

540
00:21:38,766 --> 00:21:42,066
覆盖了所有左偏红黑树的插入规则

541
00:21:42,366 --> 00:21:44,533
有脆鲨也许会感到惊讶

542
00:21:44,733 --> 00:21:46,566
这么简单的插入规则

543
00:21:46,566 --> 00:21:49,200
就能覆盖所有的插入情况吗

544
00:21:49,700 --> 00:21:50,800
七海想说

545
00:21:50,800 --> 00:21:51,666
是的！

546
00:21:51,666 --> 00:21:54,266
这四个规则分别是： 

547
00:21:54,266 --> 00:21:57,066
一，插入时总是用红色边

548
00:21:57,566 --> 00:22:00,100
二，如果插入在了右结点

549
00:22:00,166 --> 00:22:02,166
左旋相应结点即可

550
00:22:02,533 --> 00:22:06,333
三，如果插入后产生相邻的两个红边

551
00:22:06,333 --> 00:22:08,600
那就右旋相应结点

552
00:22:08,600 --> 00:22:09,700
这时会产生

553
00:22:09,700 --> 00:22:12,766
一个结点有两个红色子边的情况

554
00:22:13,333 --> 00:22:17,200
四，如果一个结点有两个红色子边

555
00:22:17,300 --> 00:22:18,933
颜色翻转即可

556
00:22:19,400 --> 00:22:20,500
需要注意的是

557
00:22:20,500 --> 00:22:22,966
插入时可能产生连锁反应

558
00:22:22,966 --> 00:22:23,333
比如

559
00:22:23,333 --> 00:22:27,066
颜色翻转可能导致红色边出现在右边

560
00:22:27,066 --> 00:22:29,133
没关系，我们见招拆招

561
00:22:29,133 --> 00:22:32,366
利用规则 2 进行正确的左旋即可

562
00:22:32,766 --> 00:22:35,400
下面我们来做这节课最后一个练习

563
00:22:35,400 --> 00:22:38,900
在如下的左偏红黑树中插入 9

564
00:22:42,166 --> 00:22:44,333
我们的插入步骤如图所示

565
00:22:44,333 --> 00:22:47,100
每一步都能找到对应的插入规则

566
00:22:47,533 --> 00:22:49,000
七海不再赘述

567
00:22:49,100 --> 00:22:50,700
大家看画面即可

568
00:22:51,100 --> 00:22:52,166
这节课最后

569
00:22:52,166 --> 00:22:55,400
我们来看左偏红黑树的性能与实现

570
00:22:55,866 --> 00:22:57,700
此前我们已经证明过

571
00:22:57,700 --> 00:23:01,300
左偏红黑树的高度是 O(log N)

572
00:23:01,733 --> 00:23:05,666
它的搜索操作与一般的二叉搜索树相同

573
00:23:05,666 --> 00:23:08,266
最差情况取决于树的高度

574
00:23:08,366 --> 00:23:11,700
所以搜索的时间复杂度为对数

575
00:23:12,200 --> 00:23:15,133
左偏红黑树的插入操作分两步

576
00:23:15,133 --> 00:23:16,466
第一步是一般的搜索

577
00:23:16,466 --> 00:23:18,366
然后创建新结点

578
00:23:18,366 --> 00:23:21,666
第二步再进行旋转或者颜色翻转

579
00:23:22,133 --> 00:23:24,766
因为要从下往上进行操作

580
00:23:24,866 --> 00:23:27,933
所以第二步时间复杂度也是对数

581
00:23:28,266 --> 00:23:29,333
综合来看

582
00:23:29,366 --> 00:23:31,700
左偏红黑树的插入操作

583
00:23:31,700 --> 00:23:33,966
时间复杂度也是对数

584
00:23:34,500 --> 00:23:35,700
至于删除操作

585
00:23:35,700 --> 00:23:37,800
我们不会在课程中涉及

586
00:23:38,133 --> 00:23:40,400
左偏红黑树的删除操作

587
00:23:40,400 --> 00:23:42,933
时间复杂度同样也是对数

588
00:23:43,300 --> 00:23:46,300
好奇的脆鲨可以自行搜索了解

589
00:23:46,300 --> 00:23:47,533
实际上也不难

590
00:23:48,133 --> 00:23:50,366
左偏红黑树的代码实现

591
00:23:50,400 --> 00:23:52,100
相比于2-3树来说

592
00:23:52,100 --> 00:23:53,400
要简单许多

593
00:23:53,500 --> 00:23:54,900
它的伪代码形式

594
00:23:54,900 --> 00:23:57,766
甚至只需要比普通的二叉搜索树

595
00:23:57,766 --> 00:23:58,666
插入操作

596
00:23:58,666 --> 00:24:00,200
多三行就够了

597
00:24:00,366 --> 00:24:05,633
这三行分别对应我们插入规则的第二第三第四条规则

598
00:24:05,766 --> 00:24:08,100
脆鲨们可以暂停查看

599
00:24:08,533 --> 00:24:09,600
那么讲到这里

600
00:24:09,600 --> 00:24:12,300
搜索树的最后一节课就讲完了

601
00:24:12,500 --> 00:24:14,100
谢谢各位脆鲨！

602
00:24:14,366 --> 00:24:16,866
不知道各位脆鲨听懂了吗？

603
00:24:17,333 --> 00:24:19,166
课程资料放在简介

604
00:24:19,300 --> 00:24:21,533
感兴趣的脆鲨可以查看

605
00:24:21,966 --> 00:24:24,500
非常感谢听完这节课的大家！

606
00:24:24,666 --> 00:24:27,800
这节课因为内容多花了七海不少时间

607
00:24:28,366 --> 00:24:30,866
谢谢大家对于前面课程的喜欢

608
00:24:30,866 --> 00:24:32,266
才让七海没有懈怠

609
00:24:32,266 --> 00:24:34,566
给大家肝出来了这期视频

610
00:24:34,933 --> 00:24:36,066
谢谢大家！

